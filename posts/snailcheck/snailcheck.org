#+AUTHOR: Jeffrey Fisher
#+filetags: snailcheck ocaml

#+hugo_base_dir: ../../
#+hugo_custom_front_matter: :math true

* todolist :noexport:

** IDEA Potentially make this a literate program
I've decided to use OCaml's built-in =Lazy.t= type after chapter 1. Maybe after I write the 1 or 2 chapters I'll decide to do the same thing with =Seq=.

Once I reach Chapter 2 or 3, and make that decision, maybe I'll decide to turn this into a literate program for the actual SnailCheck library.

If not that's fine too. Also the blog post style is potentially different from standard literate programming style.

A standard literate program does do a lot of explaining (I assume), but they tend to cover the actual code and not simplified-but-inefficient code (I assume).

** Maybe don't turn this into a real library
https://ocamlverse.net/content/testing.html

There are many OCaml libraries that provide various kinds of testing already. The [[https://kaputt.x9c.fr/][Kaputt]] library provides "enumeration-based tests, inspired by the SmallCheck tool", along with

Well, it is worth doing for practice, education, fun, and portfolio purposes. So I'll try doing it anyways. I've not written a big OCaml codebase from scratch before. And it's been a long time since I've written a big project from scratch.

* SnailCheck: Laziness from scratch in OCaml
:PROPERTIES:
:header-args: :tangle 01/chapter-01.ml :noweb strip-export
:EXPORT_FILE_NAME: snailcheck-lazy
:EXPORT_DATE: 2023-06-04
:END:

** :noexport:
#+name: chp01-import
#+begin_src ocaml :tangle no
  #use "01/chapter-01.ml";;
  let sprintf = Printf.sprintf;;
#+end_src

For whatever reason multiple noweb references, one on each line, results in extra newlines in the weaved/rendered output. So make extra automatically import =chp01-import=.

#+name: chp01-extra
#+begin_src ocaml :tangle no
  <<chp01-import>>
  #use "01/extra.ml";;
#+end_src
** todo list :noexport:
*** TODO Get help with the noweb references leaving extra blank lines in the export

** 
[[file:/posts/snailcheck-enum][Next post in this series]].

Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.

I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck [fn:pearlcheck] and [[https://hackage.haskell.org/package/leancheck][LeanCheck]]. Like them, SnailCheck's main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.

Our first stop will be laziness.

[fn:pearlcheck]
http://jmct.cc/pearlcheck.pdf

SnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.

If you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won't be covered in this series.

** Property-based testing (PBT)
Later posts will give a better idea of what property-based testing is, but for now I'll give a quick definition.

A property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.

For example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.

#+begin_src ocaml :tangle no :eval no
  let prop xs =
    xs = reverse (reverse xs)
#+end_src

The PBT library would apply this function to many different lists, making sure that it evaluates to =true= each time.

** Motivation for laziness
Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.

Many types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.

*** Attempt #1 at the natural numbers
The natural numbers are \(\{0, 1, 2, 3, ...\}\).

There is a pattern here: the "current" number is the previous number plus one.[fn:peano] We repeatedly call the function =fun n -> n + 1= on the "current" number, then consider the result the new "current" number.

Let's list them out.

#+begin_src ocaml :exports both :tangle no
  let rec nats n = n :: nats (n + 1);;
  nats 0
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

There's a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn't have enough memory to store them.

We need to be lazy, to delay computation until later.[fn:lazy]

# footnotes
[fn:peano]
In fact there is a representation of the natural numbers based on this fact, called the Peano numbers.

#+begin_src ocaml :tangle no
type peano = Z | S of peano
#+end_src

Z = "zero", S = "successor".

- Zero: src_ocaml[:exports code]{Z}
- One: src_ocaml[:exports code]{S (Z)}
- Two: src_ocaml[:exports code]{S (S (Z))}

[fn:lazy] Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.

#+begin_src haskell :tangle no :exports both :results verbatim
  let nats n = n : nats (n + 1) in
  let xs = nats 0 in
  take 10 xs
#+end_src

#+RESULTS:
: [0,1,2,3,4,5,6,7,8,9]

** Laziness
How do we represent computation without immediately evaluating it?

Functions! If you define a function with an infinite loop, it won't actually freeze your program unless you call the function.

We will represent lazy values with the type =unit -> 'a=, a function that takes one argument of type =unit=, and returns our value. =unit= is a special type that only has one value, which is also called "unit" and is written as empty paired parentheses, =()=. The argument to our lazy values carries no information, it's more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.

#+begin_src ocaml
  type 't delayed = unit -> 't
#+end_src

A more standard name for "delayed" would be [[https://en.wikipedia.org/wiki/Thunk][thunk]].

Here are some sample lazy values:

#+begin_src ocaml
  let a : int delayed = fun () -> 42;;
  let b : int delayed = fun () -> List.fold_left (+) 0 [1;2;3];;
#+end_src

For readability we will write a function for evaluating lazy values, =force=.

#+begin_src ocaml
  let force lazy_val = lazy_val ()
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp01-import>>
  sprintf "%d\n" (force a)
  ^ sprintf "%d\n" (force b);;
#+end_src

#+RESULTS:
: 42
: 6

*** Attempt #2 at natural numbers

#+begin_src ocaml :tangle no
  let rec up_from n = n :: up_from (n + 1)
  let nats : int list delayed = fun () -> up_from 0
#+end_src

We break out the implementation of =nats= into =up_from=.

We can now pass around the value =nats= without freezing, but if we try to unwrap the lazy value, we'll still infinitely recurse. We've merely delayed a problematic expression, not fixed the problem.

Instead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.

We want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.

#+begin_src ocaml :tangle no :exports both
  let rec up_from n = n :: (fun () -> up_from (n + 1))
#+end_src

#+RESULTS:
: Line 1, characters 25-52:
: 1 | let rec up_from n = n :: (fun () -> up_from (n + 1));;
:                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
: Error: This expression should not be a function, the expected type is 'a list

This code is basically what we want, but we'll need to create our own type to represent it.

** Lazy lists
#+begin_src ocaml
  type 'a lazylist = Nil | Cons of 'a * 'a lazylist delayed
#+end_src

Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.

Some example lazy lists:

#+begin_src ocaml
  let _ : 'a lazylist = Nil;;
  let _ : int lazylist = Cons (1, fun () -> Nil);;
  let _ : string lazylist = Cons ("a", fun () -> Cons ("b", fun () -> Nil));;
#+end_src

# TODO: Maybe this paragraph is too wordy?
Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.

- Infinite: lazy lists
- Finite: lazy lists OR lists

Lazy lists support both, so we always use them for the sake of uniformity.

The above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.

#+begin_src ocaml
  let rec int_range first last =
    if first > last then
      Nil
    else
      Cons (first, fun () -> int_range (first + 1) last)
#+end_src

Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.

#+begin_src ocaml :tangle no :exports both
  <<chp01-import>>
  let one_to_twenty = int_range 1 20
#+end_src

To view lazy lists, we can grab the first few elements as a regular list.

# TODO: Maybe write a lazy take? To truncate a lazy list without evaluating it? Idk if it will be used in SnailCheck though. If I were making a generic lazy list library, sure. But I'm not, so most likely won't write a lazy take.

#+begin_src ocaml
  (* Returns a regular list of the first [n] elements of [ll]. If [n] greater than
     the length of [ll], returns [ll] as a regular list. *)
  let rec take n ll =
    if n = 0 then
      []
    else (
      match ll with
      | Nil -> []
      | Cons (x, xs) -> x :: take (n - 1) (force xs)
    )
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 100 @@ int_range 1 20
#+end_src

** Infinite lists

The simplest infinite lists are just cycles.

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec rocks name =
    Cons (name ^ " rocks!", fun () -> rocks name) in
  take 3 @@ rocks "Property-based testing"
#+end_src

It doesn't have to be a function:

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec xs = Cons (1, fun () -> Cons (2, fun () -> xs)) in
  take 5 xs
#+end_src

*** Enumerating the natural numbers
We've already seen the key idea, now we need to translate it to use =lazylist=.

#+begin_src ocaml
  let rec up_from n = Cons (n, fun () -> up_from (n + 1))

  let nats : int lazylist = up_from 0
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 10 nats
#+end_src

**** TODO Since I've organized laziness into its own chapter, maybe I should use OCaml's built-in Lazy library for the rest of the chapters? Cornell CS3110's streams using =Lazy.t= are much faster than those using =unit -> 'a=. :noexport:

** OCaml built-in Lazy
OCaml has a [[https://v2.ocaml.org/api/Lazy.html][built-in lazy library]], which also does "memoization". It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn't have to, it also avoids redoing work it has already done.

OCaml also has built-in library for delayed lists, [[https://v2.ocaml.org/api/Seq.html][Seq]]. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.

*** TODO Benchmark using Lazy.t vs using unit -> 'a. :noexport:
Also maybe benchmark using built-in Seq. Maybe I'll do a split like PearlCheck, where LeanCheck is a separate library written on its own. Idk if PearlCheck created LeanCheck though. But what I mean is maybe write self-contained posts to describe making a simple PBT library from scratch, then write my own using Seq and Lazy.t if they turn out to be better or for the sake of extra compatiblity and not remaking stuff.

Also noticed Seq.t is a deferred value in itself, which may make the type of interleave a bit more natural because it will be forced to be lazy when using the default Seq instead of adding laziness. Not a big change though.

Looks like there's already a Seq.interleave function that does what I need. So I think these may end up being just blog posts. Then will also write a library but may not bother doing literate programming for it, though I haven't decided yet. I do find literate programming interesting, and want to try it in a non-blog-post style.

There's also Seq.product for making tuples.

** Sources
I learned how lazy lists worked from the [[https://cs3110.github.io/textbook/chapters/ds/sequence.html][Cornell CS 3110 textbook]], and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.

* SnailCheck: Generating values by enumeration
:PROPERTIES:
:EXPORT_FILE_NAME: snailcheck-enum
:EXPORT_TITLE: SnailCheck: Enumerating types
:EXPORT_DATE: 2023-06-08
:header-args: :tangle 02/chapter-02.ml :noweb strip-export :results verbatim
:EXPORT_HUGO_DRAFT: true
:END:

** :noexport:
#+name: chp02-import
#+begin_src ocaml :tangle no
  #use "01/chapter-01.ml";;
  #use "02/chapter-02.ml";;
#+end_src

#+name: chp02-extra
#+begin_src ocaml :tangle no
  <<chp02-import>>
  #use "02/extra.ml";;
#+end_src

** 
[[file:/posts/snailcheck-lazy][Previous post in this series]].

In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.

** Enumerating booleans
Enumerating booleans is simpler than the naturals, but it's worth seeing. We'll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.

#+begin_src ocaml
  let rec of_list xs =
    match xs with
    | [] -> Nil
    | x::xs -> Cons (x, fun () -> of_list xs)
#+end_src

#+begin_src ocaml
  let bool : bool lazylist = of_list [true; false]
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  take 2 bool
#+end_src

#+RESULTS:
: - : bool list = [true; false]

Note: We are doing some punning here to allow conciseness. [fn:pun] When used in types "bool" will still refer to the the standard boolean type. But when used in expressions "bool" means this particular lazy list.

[fn:pun] We're also doing punning because [[https://c-cube.github.io/qcheck/][QCheck]] does it that way, and we want to be compatible with QCheck.

** Enumerating integers
*** Problem
Listing the integers is non-obvious because unlike the naturals there is no "starting point". In math you can discuss the range \((-\infty, \infty)\), but in code we can't start at negative infinity.

OCaml's =int= type does technically have a starting point, =min_int=, which seems to be \(-2^{62}\). Maybe we could do =let int = up_from min_int=? There are a few problems with this:

1. For a while all you'll be seeing is negative numbers with a large magnitude. It's easier to work with smaller numbers, and we also want to check zero and positive numbers. One of the benefits of enumerative property-based testing is trying the simplest cases first---with random generation you tend to get huge test values that need to be "shrinked".
2. "a while" is probably longer than a human lifespan. Rough calculations with a 5 millisecond time per check gave me an 11-digit number of /years/. 5 ms is perhaps a long time for executing a function, but even at the nanosecond scale you can't exhaust the integers. A quick Internet search says even just incrementing a counter from 0 to 2^{64} (not even checking properties) would take around 100 years.
3. Sometimes we may want to use a special integer type that can represent arbitrarily-large integers. Then there will be no such thing as =min_int=.

*** Solution
There is a way to arrange the integers that gives them a starting point and gives the simplest cases first: \(0, -1, 1, -2, 2, -3, 3, \ldots\) [fn:well-ordering]

We could express this as a single generator function like we did with the naturals:

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  let int : int lazylist =
    let rec ints' n =
      Cons (-n, fun () ->
               Cons (n, fun () -> ints' (n + 1))) in
    Cons (0, fun () -> ints' 1)
  ;;

  take 9 int
#+end_src

#+RESULTS:
: - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4]

However, we will express it in a way that I feel is more elegant. It will be useful to examine this technique with the integers first, because we will need it for more complex types later.

\[\mathbb{Z} = \mathbb{N} \cup \{-1, -2, -3, \ldots\}\]

We can break the integers into pieces. If we combine the natural numbers and the negative integers, we get the set of all integers.

The common way to combine lists is appending.

#+begin_src ocaml :tangle 02/extra.ml
  let rec append xs ys =
    match xs, ys with
    | Nil, ys -> ys
    | Cons (x, xs), ys ->
       Cons (x, fun () -> append (force xs) ys)
#+end_src

Let's confirm that our lazy list =append= works:

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 6 @@ append (of_list [1;2;3]) (of_list [4;5;6])
#+end_src

#+RESULTS:
: - : int list = [1; 2; 3; 4; 5; 6]

Now let's try making the integers:

#+begin_src ocaml
  let rec down_from n = Cons (n, fun () -> down_from (n - 1))
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  let int = append nats (down_from (-1)) in
  take 9 int
#+end_src

#+RESULTS:
: - : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8]

Oh no, we aren't seeing any negatives! There are infinitely many naturals, so we'll never get to the negatives.

If we make a slight change to our =append= function, we can get the behavior we want.

#+begin_src ocaml
  let rec interleave xs ys =
    match xs, ys with
    | Nil, ys -> ys
    | Cons (x, xs), ys ->
       Cons (x, fun () -> interleave ys (force xs))
           (* Difference: append (force xs) ys *)

  (* Operator form. *)
  let ( @| ) = interleave

  let int : int lazylist = nats @| (down_from (-1))
#+end_src

In the recursive call we now swap the position of =xs= and =ys=, so we will get the behavior of alternating which list we grab from.

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 9 int
#+end_src

#+RESULTS:
: - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4]

[fn:well-ordering] Apparently this is called the [[https://en.wikipedia.org/wiki/Well-order#Integers][well-ordering of the integers]]. I'd seen this ordering before, and I recently learned the Well-Ordering Principle, but hadn't made the connection until looking it up just now.

** Enumerating tuples
Not all functions deal with simple scalar types. We also want to enumerate structured types, starting with tuples.

First let's add the ability to map over lazy lists.

#+begin_src ocaml
  let rec map f xs =
    match xs with
    | Nil -> Nil
    | Cons (x, xs) ->
       Cons (f x,
             fun () -> map f (force xs))
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  let square x = x * x in
  let perfect_squares = map square nats in
  take 10 perfect_squares
#+end_src

#+RESULTS:
: - : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81]

#+begin_src ocaml
  let rec pair_with x ll =
    map (fun y -> (x, y)) ll

  let rec pair xlist ylist =
    match xlist, ylist with
    | Cons (x, xrest), Cons (y, yrest) ->
       (* x paired with every y, interleaved with: pair xs ylist *)
       Cons ((x,y),
             fun () -> pair_with x (force yrest) @| pair (force xrest) ylist)
    | Nil, _ -> Nil
    | _, Nil -> Nil
#+end_src

The key idea is to pair up the first =x= with every =y= in =ylist=, then combine that with the pairing of =xrest= with =ylist=.

Note that =pair_with x (force yrest)= actually uses =yrest=, so it skips the first =y=. This is fine though because we have the pairing of =x= and the first =y= with =Cons ((x,y), ...)=.

The =Cons ((x,y), ...)= piece is a bit inelegant, but necessary with the current implementation of =interleave=. Later we will solve this issue and clean up =pair=.

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  take 10 @@ pair_with 42 (of_list [1;2;3;4;5])
#+end_src

#+RESULTS:
: - : (int * int) list = [(42, 1); (42, 2); (42, 3); (42, 4); (42, 5)]

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 10 @@ pair bool bool
#+end_src

#+RESULTS:
: - : (bool * bool) list =
: [(true, true); (true, false); (false, true); (false, false)]

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 10 @@ pair int int
#+end_src

#+RESULTS:
: - : (int * int) list =
: [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2);
:  (-1, 1); (0, -3)]

We can of course mix different types.

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 10 @@ pair int bool
#+end_src

#+RESULTS:
: - : (int * bool) list =
: [(0, true); (0, false); (-1, true); (-1, false); (1, true); (1, false);
:  (-2, true); (-2, false); (2, true); (2, false)]

*** Triples and n-tuples
Two is a magic number. We can mimic n-tuples using nested pairs.

For example: =(1, (2, 3))=.

#+begin_src ocaml
  let triple xs ys zs =
    let triple_of_nest (a, (b, c)) = (a, b, c) in
    map triple_of_nest (pair xs (pair ys zs))
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  take 5 @@ triple int (pair bool int) int
#+end_src

#+RESULTS:
: - : (int * (bool * int) * int) list =
: [(0, (true, 0), 0); (0, (true, 0), -1); (-1, (true, 0), 0);
:  (0, (true, -1), 0); (-1, (true, 0), -1)]

** Enumerating algebraic data types (ADT)
Here's an interesting but still simple ADT: a binary tree.

#+begin_src ocaml :tangle 02/extra.ml
  type 'a tree = Leaf | Branch of 'a * 'a tree * 'a tree
#+end_src

The enumeration of ADT constructors can be built directly off of tuple enumeration. We enumerate n-tuples, where n is the number of arguments to the constructor, then construct values.

#+begin_src ocaml
  let cons0 cons = of_list [cons]
  let cons1 cons a = map cons a
  let cons2 cons a b = map cons (pair a b)
  let cons3 cons a b c = map cons (triple a b c)
#+end_src

In OCaml constructors cannot be passed around like functions, so we will define function wrappers to pass to =consN=.

#+begin_src ocaml :tangle 02/extra.ml
  let leaf = Leaf;;
  let branch (v, l, r) = Branch (v, l, r)
#+end_src

The =branch= function converts an appropriate tuple into a tree branch.

#+begin_src ocaml :tangle 02/extra.ml
  let rec tree_a typ =
    cons0 leaf
    @| cons3 branch typ (tree_a typ) (tree_a typ)
#+end_src

The type =tree= has two constructors. We start with the simple one, =Leaf=. It is a nullary constructor (no arguments), so we do =cons0 leaf= to enumerate it.

The other constructor is =Branch=, which has 3 parts, so we use =cons3=. The first part is of type ='a=, the type the tree is parameterized by. We have the =typ= argument to take in the enumeration of ='a=, so we do =cons3 branch typ=. The next two parts are both of type tree, so we have =cons3 branch typ (tree_a typ) (tree_a typ)=.

Writing enumerations of algebraic data types is a simple, mechanical process.[fn:mechanical]

Let's check out the result.

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 5 @@ (tree_a int)
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

Turns out I lied a bit. What went wrong?

The top level function in the body of =tree_a= is =@|= (a.k.a. =interleave=). OCaml uses [[https://en.wikipedia.org/wiki/Strict_programming_language][strict evaluation]], so we evaluate the arguments before evaluating the function. The left argument =cons0 leaf= is fine. The problem arises in the right argument, which has recursive calls to =tree_a=.

With recursion it is usually important to have:

1. A base case.
2. Recursive calls make the input "smaller", approaching the base case.
3. Conditional that checks whether to perform the base or recursive case.

We have a base case of =cons0 leaf=, but we don't have a conditional. Conditionals are special in that only some of their arguments/branches are evaluated each time, while functions have *all* of their arguments evaluated every time.

The problem is that we are always evaluating the recursive calls in =cons3 branch typ (tree_a typ) (tree_a typ)=, so we recurse infinitely.

[fn:mechanical] That means we can automate the generation of enumerations of algebraic data types! I may write a post about this in the future.

*** Solution
Imagine you are =tree_a=. This is roughly the behavior we want:

- For the first tree, I'll give you a =Leaf=.
- For the second tree, I'll give you a =Branch=.
  - To make a branch, I need to make a ='a=. That's easy, I use =typ=.
  - I also need to make two of ='a tree=. To do that, I make two nested calls of =tree_a typ=.
    - I'm the first nested call. I'll give you the first tree in the enumeration. That's =Leaf=.
    - I'm the second nested call. I'll give you the first tree in the enumeration. That's =Leaf=.
  - I've completed giving =Branch Leaf Leaf=.
- For the third tree, ...

If we grab the base case (=Leaf=) first, we can manage to build recursive cases (=Branch=).

We can't do this with strict evaluation, so we need to add a bit of laziness. We will write =lazy_interleave= so that its arguments are both lazy (=delayed=), so we won't get stuck on recursive calls encountered while evaluating the arguments to =lazy_interleave=.[fn:lazy-interleave]

#+begin_src ocaml
  let rec lazy_interleave (xs : 'a lazylist delayed) (ys: 'a lazylist delayed) =
    let xs = force xs in
    match xs with
    | Nil -> force ys
    | Cons (x, xs) ->
       Cons (x, fun () -> lazy_interleave ys xs)

  let ( @|| ) = lazy_interleave
#+end_src

Now we can enumerate trees.

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  let rec tree typ =
    let a = fun () -> cons0 leaf in
    let b = fun () -> cons3 branch typ (tree typ) (tree typ) in
    a @|| b
  in

  take 3 @@ tree int
#+end_src

#+RESULTS:
: - : int tree list =
: [Leaf; Branch (0, Leaf, Leaf); Branch (0, Leaf, Branch (0, Leaf, Leaf))]

[fn:lazy-interleave]
There's not much use in keeping the non-lazy version of =interleave= around; I consider it broken. I only gave =lazy_interleave= a new name as a shortcut to appease the literate programming setup I'm using.

*** Order matters
Remember when I said we needed to grab the base case(s) before the recursive case(s)? With the current code, that's true.

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  let rec tree_bad typ =
    let a = fun () -> cons3 branch typ (tree_bad typ) (tree_bad typ) in
    let b = fun () -> cons0 leaf in
    a @|| b
  in
  take 5 @@ tree_bad int
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

This is problematic. It's annoying to remember and results in an unhelpful error message.[fn:order-error]

It's not simply a matter of laziness. [[http://jmct.cc/pearlcheck.pdf][PearlCheck]], which is written in the lazy language Haskell, also faces this problem---though it is solved later in the paper.[fn:pearlcheck-order]

It is possible to solve this problem in SnailCheck if we switch from simple enumerated lists to =tiers=, like PearlCheck uses. That may be covered in a later post, but for now you can check out the PearlCheck paper.

[fn:order-error]
If you know of a way to detect the problem and provide a helpful error message, let me know!

Maybe stack overflow is a catchable exception, and could print an error message that suggests that the problem could be the order of the ADT cases. However, I say "suggest" because there could be other reasons for stack overflow; this merely detects a symptom rather than the problem.

I'm thinking proper detection would require some sort of static analysis. Maybe it could be done with a [[https://ocaml.org/docs/metaprogramming][PPX]].

[fn:pearlcheck-order]
PearlCheck doesn't mention this problem, but if you copy the code up through "Mark II: Algebraic Datatypes" you can reproduce the problem on this example:

#+begin_src haskell :tangle no
  instance Listable Expr where
    -- Different from the one in the paper.
    -- Recursive case comes first / on the left.
    list = cons2 Add \/ cons1 Val

  -- Gets stuck here on infinite recursion.
  take 5 (list :: [Expr])
#+end_src

The error goes away at "Mark IV: Fair Enumeration" because of the swap from =list= to =tiers=.

** Enumerating lists
Lists in OCaml are essentially an algebraic data type, so we can enumerate them now.

#+begin_src ocaml
  let rec list typ =
    let cons (x, xs) = x :: xs in
    (fun () -> cons0 [])
    @|| (fun () -> cons2 cons typ (list typ))
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  take 5 @@ list bool
#+end_src

#+RESULTS:
: - : bool list list = [[]; [true]; [true; true]; [false]; [true; true; true]]

** Elegant =pair=
As promised, here is the elegant version of =pair=. This eliminates the =Cons ((x,y), ...)= and expresses it only with =pair_with= and a recursive call.

#+begin_src ocaml :tangle 02/extra.ml
  let rec elegant_pair xlist ylist =
    match xlist, ylist with
    | Cons (x, xrest), Cons (y, yrest) ->
       (* x paired with every y, then repeat with xrest. *)
       (fun () -> pair_with x ylist)
       @|| (fun () -> elegant_pair (force xrest) ylist)
    | Nil, _ -> Nil
    | _, Nil -> Nil
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 10 @@ elegant_pair int int
#+end_src

#+RESULTS:
: - : (int * int) list =
: [(0, 0); (-1, 0); (0, -1); (1, 0); (0, 1); (-1, -1); (0, -2); (-2, 0);
:  (0, 2); (-1, 1)]

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 10 @@ pair int int
#+end_src

#+RESULTS:
: - : (int * int) list =
: [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2);
:  (-1, 1); (0, -3)]

The order is a bit different, but it's still correct.

** See also
This may be the last SnailCheck post, so I'll leave you with some pointers if you're interested in learning more.

- As mentioned previously this series is essentially a port of the [[http://jmct.cc/pearlcheck.pdf][PearlCheck]] paper to OCaml.
  - PearlCheck is a "tutorial reconstruction" of LeanCheck: https://hackage.haskell.org/package/leancheck
  - So far the SnailCheck posts have covered the parts I struggled to translate to OCaml, but there is a lot more covered by PearlCheck that's worth reading.

- According to PearlCheck, SmallCheck was the first enumerative PBT tool for Haskell.
  - Paper: https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf
  - An implementation: https://github.com/Bodigrim/smallcheck

- Feat: functional enumeration of algebraic types
  - Paper: https://dl.acm.org/doi/abs/10.1145/2364506.2364515
    - "Feat provides efficient 'random access' to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck)"
  - An OCaml library inspired by Feat: https://gitlab.inria.fr/fpottier/feat/

- There are a variety of testing frameworks for OCaml. Several of them support some form of property-based testing.
  - https://ocamlverse.net/content/testing.html

* TODO SnailCheck: Upcoming
** Potential chapters:
- Laziness from scratch
- Enumerating types
- ? Converting to using tiers
- ? Automatic generation of enumerators for arbitrary ADTs
  - Might involve learning PPX, which I'm interested in.
  - Check out [[https://github.com/ocaml-ppx/ppx_deriving][ppx_deriving]] library
- ? Enumerators for types with pre and post conditions
  - PearlCheck covers this a bit.
  - I want to learn how to do this b/c I'm interested in using property-based testing well, but I'm not sure if I will write a post about this. Will find out later.
- ? Integrating with testing frameworks and QCheck.

** TODO If describe =tiers=, make sure we support mutually recursive types

** TODO Maybe: Restructuring to use =tiers= instead of =list=

** TODO
TODO: Are there any mutually recursive data types that don't result in their only possible values being infinite cycles? Yes: https://en.wikipedia.org/wiki/Recursive_data_type#Mutually_recursive_data_types. However they still have base cases so idk if they'd have trouble here. Maybe the order problem doesn't actually prevent you from doing anything, and is just annoying.

TODO: Are we able to generate infinite cycles? Obviously you can explicitly write the enumeration but can we provide a nicer way of doing so?

** TODO Maybe: PBT functions
Stuff like LeanCheck or QuickCheck has.

- =exists= aka =search=
- =holds=
- =checkFor=

Not sure exactly what I'll want as I do want a QCheck-compatible interface.

** TODO Maybe: QCheck-compatible interface
Pretty sure I do want this in the library, but not sure if I want to cover it in the blog posts.

*** IDEA Combined QCheck and SnailCheck
Can have multiple tests in the same file that use one or the other based on which is best.

For example if you want an existence test, you'd use SnailCheck.

Then can also have a QCheck-compatible interface, so that you can just rename a module alias/import at the top of the file and switch all the QCheck-compatible (non existence, don't require enumeration) tests to SnailCheck or QCheck, back-and-forth with a one-line change.

