#+AUTHOR: Jeffrey Fisher
#+filetags: snailcheck ocaml

#+hugo_base_dir: ../../
#+hugo_custom_front_matter: :math true

* todolist :noexport:

** IDEA Potentially make this a literate program
I've decided to use OCaml's built-in =Lazy.t= type after chapter 1. Maybe after I write the 1 or 2 chapters I'll decide to do the same thing with =Seq=.

Once I reach Chapter 2 or 3, and make that decision, maybe I'll decide to turn this into a literate program for the actual SnailCheck library.

If not that's fine too. Also the blog post style is potentially different from standard literate programming style.

A standard literate program does do a lot of explaining (I assume), but they tend to cover the actual code and not simplified-but-inefficient code (I assume).

* SnailCheck: Laziness from scratch in OCaml
:PROPERTIES:
:header-args: :tangle 01/chapter-01.ml :noweb strip-export
:EXPORT_FILE_NAME: snailcheck_laziness-from-scratch-in-ocaml
:EXPORT_DATE: 2023-06-04
:END:

** :noexport:
#+name: chp01-import
#+begin_src ocaml :tangle no
  #use "01/chapter-01.ml";;
  let sprintf = Printf.sprintf;;
#+end_src

For whatever reason multiple noweb references, one on each line, results in extra newlines in the weaved/rendered output. So make extra automatically import =chp01-import=.

#+name: chp01-extra
#+begin_src ocaml :tangle no
  <<chp01-import>>
  #use "01/extra.ml";;
#+end_src
** todo list :noexport:
*** TODO Get help with the noweb references leaving extra blank lines in the export

** 
Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.

I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck [fn:pearlcheck] and [[https://hackage.haskell.org/package/leancheck][LeanCheck]]. Like them, SnailCheck's main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.

Our first stop will be laziness.

[fn:pearlcheck]
http://jmct.cc/pearlcheck.pdf

SnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.

If you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won't be covered in this series.

** Property-based testing (PBT)
Later posts will give a better idea of what property-based testing is, but for now I'll give a quick definition.

A property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.

For example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.

#+begin_src ocaml :tangle no :eval no
  let prop xs =
    xs = reverse (reverse xs)
#+end_src

The PBT library would apply this function to many different lists, making sure that it evaluates to =true= each time.

** Motivation for laziness
Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.

Many types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.

*** Attempt #1 at the natural numbers
The natural numbers are \(\{0, 1, 2, 3, ...\}\).

There is a pattern here: the "current" number is the previous number plus one.[fn:peano] We repeatedly call the function =fun n -> n + 1= on the "current" number, then consider the result the new "current" number.

Let's list them out.

#+begin_src ocaml :exports both :tangle no
  let rec nats n = n :: nats (n + 1);;
  nats 0
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

There's a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn't have enough memory to store them.

We need to be lazy, to delay computation until later.[fn:lazy]

# footnotes
[fn:peano]
In fact there is a representation of the natural numbers based on this fact, called the Peano numbers.

#+begin_src ocaml :tangle no
type peano = Z | S of peano
#+end_src

Z = "zero", S = "successor".

- Zero: src_ocaml[:exports code]{Z}
- One: src_ocaml[:exports code]{S (Z)}
- Two: src_ocaml[:exports code]{S (S (Z))}

[fn:lazy] Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.

#+begin_src haskell :tangle no :exports both :results verbatim
  let nats n = n : nats (n + 1) in
  let xs = nats 0 in
  take 10 xs
#+end_src

#+RESULTS:
: [0,1,2,3,4,5,6,7,8,9]

** Laziness
How do we represent computation without immediately evaluating it?

Functions! If you define a function with an infinite loop, it won't actually freeze your program unless you call the function.

We will represent lazy values with the type =unit -> 'a=, a function that takes one argument of type =unit=, and returns our value. =unit= is a special type that only has one value, which is also called "unit" and is written as empty paired parentheses, =()=. The argument to our lazy values carries no information, it's more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.

#+begin_src ocaml
type 't delayed = unit -> 't
#+end_src

A more standard name for "delayed" would be [[https://en.wikipedia.org/wiki/Thunk][thunk]].

Here are some sample lazy values:

#+begin_src ocaml
  let a : int delayed = fun () -> 42;;
  let b : int delayed = fun () -> List.fold_left (+) 0 [1;2;3];;
#+end_src

For readability we will write a function for evaluating lazy values, =force=.

#+begin_src ocaml
  let force lazy_val = lazy_val ()
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp01-import>>
  sprintf "%d\n" (force a)
  ^ sprintf "%d\n" (force b);;
#+end_src

#+RESULTS:
: 42
: 6

*** Attempt #2 at natural numbers

#+begin_src ocaml :tangle no
  let rec up_from n = n :: up_from (n + 1)
  let nats : int list delayed = fun () -> up_from 0
#+end_src

We break out the implementation of =nats= into =up_from=.

We can now pass around the value =nats= without freezing, but if we try to unwrap the lazy value, we'll still infinitely recurse. We've merely delayed a problematic expression, not fixed the problem.

Instead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.

We want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.

#+begin_src ocaml :tangle no :exports both
  let rec up_from n = n :: (fun () -> up_from (n + 1))
#+end_src

#+RESULTS:
: Line 1, characters 25-52:
: 1 | let rec up_from n = n :: (fun () -> up_from (n + 1));;
:                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
: Error: This expression should not be a function, the expected type is 'a list

This code is basically what we want, but we'll need to create our own type to represent it.

** Lazy lists
#+begin_src ocaml
type 'a lazylist = Nil | Cons of 'a * 'a lazylist delayed
#+end_src

Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.

Some example lazy lists:

#+begin_src ocaml
  let _ : 'a lazylist = Nil;;
  let _ : int lazylist = Cons (1, fun () -> Nil);;
  let _ : string lazylist = Cons ("a", fun () -> Cons ("b", fun () -> Nil));;
#+end_src

# TODO: Maybe this paragraph is too wordy?
Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.

- Infinite: lazy lists
- Finite: lazy lists OR lists

Lazy lists support both, so we always use them for the sake of uniformity.

The above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.

#+begin_src ocaml
  let rec int_range first last =
    if first > last then
      Nil
    else
      Cons (first, fun () -> int_range (first + 1) last)
#+end_src

Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.

#+begin_src ocaml :tangle no :exports both
  <<ch01-import>>
  let one_to_twenty = int_range 1 20
#+end_src

To view lazy lists, we can grab the first few elements as a regular list.

# TODO: Maybe write a lazy take? To truncate a lazy list without evaluating it? Idk if it will be used in SnailCheck though. If I were making a generic lazy list library, sure. But I'm not, so most likely won't write a lazy take.

#+begin_src ocaml
  (* Returns a regular list of the first [n] elements of [ll]. If [n] greater than
     the length of [ll], returns [ll] as a regular list. *)
  let rec take n ll =
    if n = 0 then
      []
    else (
      match ll with
      | Nil -> []
      | Cons (x, xs) -> x :: take (n - 1) (force xs)
    )
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 100 @@ int_range 1 20
#+end_src

** Infinite lists

The simplest infinite lists are just cycles.

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec rocks name =
    Cons (name ^ " rocks!", fun () -> rocks name) in
  take 3 @@ rocks "Property-based testing"
#+end_src

It doesn't have to be a function:

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec xs = Cons (1, fun () -> Cons (2, fun () -> xs)) in
  take 5 xs
#+end_src

*** Enumerating the natural numbers
We've already seen the key idea, now we need to translate it to use =lazylist=.

#+begin_src ocaml
  let rec up_from n = Cons (n, fun () -> up_from (n + 1))

  let nats : int lazylist = up_from 0
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 10 nats
#+end_src

**** TODO Since I've organized laziness into its own chapter, maybe I should use OCaml's built-in Lazy library for the rest of the chapters? Cornell CS3110's streams using =Lazy.t= are much faster than those using =unit -> 'a=. :noexport:

** OCaml built-in Lazy
OCaml has a [[https://v2.ocaml.org/api/Lazy.html][built-in lazy library]], which also does "memoization". It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn't have to, it also avoids redoing work it has already done.

For the rest of the series I will use the built-in =Lazy.t=.

OCaml also has built-in library for delayed lists, [[https://v2.ocaml.org/api/Seq.html][Seq]]. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.

*** TODO Benchmark using Lazy.t vs using unit -> 'a. :noexport:
Also maybe benchmark using built-in Seq. Maybe I'll do a split like PearlCheck, where LeanCheck is a separate library written on its own. Idk if PearlCheck created LeanCheck though. But what I mean is maybe write self-contained posts to describe making a simple PBT library from scratch, then write my own using Seq and Lazy.t if they turn out to be better or for the sake of extra compatiblity and not remaking stuff.

Also noticed Seq.t is a deferred value in itself, which may make the type of interleave a bit more natural because it will be forced to be lazy when using the default Seq instead of adding laziness. Not a big change though.

Looks like there's already a Seq.interleave function that does what I need. So I think these may end up being just blog posts. Then will also write a library but may not bother doing literate programming for it, though I haven't decided yet. I do find literate programming interesting, and want to try it in a non-blog-post style.

There's also Seq.product for making tuples.

** Sources
I learned how lazy lists worked from the [[https://cs3110.github.io/textbook/chapters/ds/sequence.html][Cornell CS 3110 textbook]], and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.

* TODO SnailCheck: Enumerating types
:PROPERTIES:
:EXPORT_FILE_NAME: snailcheck_chapter-2
:EXPORT_TITLE: SnailCheck: Chapter 2
:EXPORT_DATE: 2023-05-28
:END:

We've already seen the enumeration of the natural numbers.

** TODO Mention that for integers we could do it without =interleave=
Could define a function for incrementing and alternating sign. However the code ends up being less elegant, and =interleave= comes in handy a lot and especially for ADTs.

Maybe this can be a footnote. Not sure if I want to show actual code for doing so. Maybe I'll write it out and decide based on how long it is.

#+begin_src haskell :tangle no
  ints' n = n : (-n) : (ints' $ n + 1)
  ints = 0 : (ints' 1)
#+end_src

** TODO ? Enumerating algebraic data types (ADT)
This may go in chapter 3. Decide based on how long (how many words / estimated reading time) chapter 2 ends up being.

On the one hand, would be nice to put all the type enumeration together. On the other hand, it could be nice to have a short and sweet post that describes the problem with a non-lazy =interleave=.

* TODO SnailCheck: Upcoming

** TODO Show the recursive ADT ordering problem
When using =list= instead of =tiers=, when writing the definition for an ADT you must specify the non-recursive cases before the recursive cases, even with lazy =interleave=. Otherwise you get infinite recursion.

I'm not sure yet whether I want to describe how to fix this problem (and the unfair enumeration) with =tiers=, or if I just want to point people to PearlCheck.

*** TODO Mention that this occurs in Haskell/PearlCheck as well
I'm pretty sure PearlCheck doesn't mention/demonstrate it, but if you copy the code up to before =tiers= you get the same issue.

*** TODO If describe =tiers=, make sure we support mutually recursive types

** TODO Maybe: Restructuring to use =tiers= instead of =list=

** TODO Maybe: PBT functions
Stuff like LeanCheck or QuickCheck has.

- =exists= aka =search=
- =holds=
- =checkFor=

Not sure exactly what I'll want as I do want a QCheck-compatible interface.

** TODO Maybe: QCheck-compatible interface
Pretty sure I do want this in the library, but not sure if I want to cover it in the blog posts.

*** IDEA Combined QCheck and SnailCheck
Can have multiple tests in the same file that use one or the other based on which is best.

For example if you want an existence test, you'd use SnailCheck.

Then can also have a QCheck-compatible interface, so that you can just rename a module alias/import at the top of the file and switch all the QCheck-compatible (non existence, don't require enumeration) tests to SnailCheck or QCheck, back-and-forth with a one-line change.

