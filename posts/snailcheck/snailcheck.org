#+AUTHOR: Jeffrey Fisher
#+filetags: snailcheck ocaml

#+hugo_base_dir: ../../
#+hugo_custom_front_matter: :math true

* todolist :noexport:

** IDEA Potentially make this a literate program
I've decided to use OCaml's built-in =Lazy.t= type after chapter 1. Maybe after I write the 1 or 2 chapters I'll decide to do the same thing with =Seq=.

Once I reach Chapter 2 or 3, and make that decision, maybe I'll decide to turn this into a literate program for the actual SnailCheck library.

If not that's fine too. Also the blog post style is potentially different from standard literate programming style.

A standard literate program does do a lot of explaining (I assume), but they tend to cover the actual code and not simplified-but-inefficient code (I assume).

* SnailCheck: Laziness from scratch in OCaml
:PROPERTIES:
:header-args: :tangle 01/chapter-01.ml :noweb strip-export
:EXPORT_FILE_NAME: snailcheck_laziness-from-scratch-in-ocaml
:EXPORT_DATE: 2023-06-04
:END:

** :noexport:
#+name: chp01-import
#+begin_src ocaml :tangle no
  #use "01/chapter-01.ml";;
  let sprintf = Printf.sprintf;;
#+end_src

For whatever reason multiple noweb references, one on each line, results in extra newlines in the weaved/rendered output. So make extra automatically import =chp01-import=.

#+name: chp01-extra
#+begin_src ocaml :tangle no
  <<chp01-import>>
  #use "01/extra.ml";;
#+end_src
** todo list :noexport:
*** TODO Get help with the noweb references leaving extra blank lines in the export

** 
Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.

I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck [fn:pearlcheck] and [[https://hackage.haskell.org/package/leancheck][LeanCheck]]. Like them, SnailCheck's main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.

Our first stop will be laziness.

[fn:pearlcheck]
http://jmct.cc/pearlcheck.pdf

SnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.

If you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won't be covered in this series.

** Property-based testing (PBT)
Later posts will give a better idea of what property-based testing is, but for now I'll give a quick definition.

A property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.

For example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.

#+begin_src ocaml :tangle no :eval no
  let prop xs =
    xs = reverse (reverse xs)
#+end_src

The PBT library would apply this function to many different lists, making sure that it evaluates to =true= each time.

** Motivation for laziness
Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.

Many types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.

*** Attempt #1 at the natural numbers
The natural numbers are \(\{0, 1, 2, 3, ...\}\).

There is a pattern here: the "current" number is the previous number plus one.[fn:peano] We repeatedly call the function =fun n -> n + 1= on the "current" number, then consider the result the new "current" number.

Let's list them out.

#+begin_src ocaml :exports both :tangle no
  let rec nats n = n :: nats (n + 1);;
  nats 0
#+end_src

#+RESULTS:
: Stack overflow during evaluation (looping recursion?).

There's a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn't have enough memory to store them.

We need to be lazy, to delay computation until later.[fn:lazy]

# footnotes
[fn:peano]
In fact there is a representation of the natural numbers based on this fact, called the Peano numbers.

#+begin_src ocaml :tangle no
type peano = Z | S of peano
#+end_src

Z = "zero", S = "successor".

- Zero: src_ocaml[:exports code]{Z}
- One: src_ocaml[:exports code]{S (Z)}
- Two: src_ocaml[:exports code]{S (S (Z))}

[fn:lazy] Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.

#+begin_src haskell :tangle no :exports both :results verbatim
  let nats n = n : nats (n + 1) in
  let xs = nats 0 in
  take 10 xs
#+end_src

#+RESULTS:
: [0,1,2,3,4,5,6,7,8,9]

** Laziness
How do we represent computation without immediately evaluating it?

Functions! If you define a function with an infinite loop, it won't actually freeze your program unless you call the function.

We will represent lazy values with the type =unit -> 'a=, a function that takes one argument of type =unit=, and returns our value. =unit= is a special type that only has one value, which is also called "unit" and is written as empty paired parentheses, =()=. The argument to our lazy values carries no information, it's more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.

#+begin_src ocaml
  type 't delayed = unit -> 't
#+end_src

A more standard name for "delayed" would be [[https://en.wikipedia.org/wiki/Thunk][thunk]].

Here are some sample lazy values:

#+begin_src ocaml
  let a : int delayed = fun () -> 42;;
  let b : int delayed = fun () -> List.fold_left (+) 0 [1;2;3];;
#+end_src

For readability we will write a function for evaluating lazy values, =force=.

#+begin_src ocaml
  let force lazy_val = lazy_val ()
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp01-import>>
  sprintf "%d\n" (force a)
  ^ sprintf "%d\n" (force b);;
#+end_src

#+RESULTS:
: 42
: 6

*** Attempt #2 at natural numbers

#+begin_src ocaml :tangle no
  let rec up_from n = n :: up_from (n + 1)
  let nats : int list delayed = fun () -> up_from 0
#+end_src

We break out the implementation of =nats= into =up_from=.

We can now pass around the value =nats= without freezing, but if we try to unwrap the lazy value, we'll still infinitely recurse. We've merely delayed a problematic expression, not fixed the problem.

Instead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.

We want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.

#+begin_src ocaml :tangle no :exports both
  let rec up_from n = n :: (fun () -> up_from (n + 1))
#+end_src

#+RESULTS:
: Line 1, characters 25-52:
: 1 | let rec up_from n = n :: (fun () -> up_from (n + 1));;
:                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
: Error: This expression should not be a function, the expected type is 'a list

This code is basically what we want, but we'll need to create our own type to represent it.

** Lazy lists
#+begin_src ocaml
  type 'a lazylist = Nil | Cons of 'a * 'a lazylist delayed
#+end_src

Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.

Some example lazy lists:

#+begin_src ocaml
  let _ : 'a lazylist = Nil;;
  let _ : int lazylist = Cons (1, fun () -> Nil);;
  let _ : string lazylist = Cons ("a", fun () -> Cons ("b", fun () -> Nil));;
#+end_src

# TODO: Maybe this paragraph is too wordy?
Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.

- Infinite: lazy lists
- Finite: lazy lists OR lists

Lazy lists support both, so we always use them for the sake of uniformity.

The above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.

#+begin_src ocaml
  let rec int_range first last =
    if first > last then
      Nil
    else
      Cons (first, fun () -> int_range (first + 1) last)
#+end_src

Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.

#+begin_src ocaml :tangle no :exports both
  <<chp01-import>>
  let one_to_twenty = int_range 1 20
#+end_src

To view lazy lists, we can grab the first few elements as a regular list.

# TODO: Maybe write a lazy take? To truncate a lazy list without evaluating it? Idk if it will be used in SnailCheck though. If I were making a generic lazy list library, sure. But I'm not, so most likely won't write a lazy take.

#+begin_src ocaml
  (* Returns a regular list of the first [n] elements of [ll]. If [n] greater than
     the length of [ll], returns [ll] as a regular list. *)
  let rec take n ll =
    if n = 0 then
      []
    else (
      match ll with
      | Nil -> []
      | Cons (x, xs) -> x :: take (n - 1) (force xs)
    )
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 100 @@ int_range 1 20
#+end_src

** Infinite lists

The simplest infinite lists are just cycles.

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec rocks name =
    Cons (name ^ " rocks!", fun () -> rocks name) in
  take 3 @@ rocks "Property-based testing"
#+end_src

It doesn't have to be a function:

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  let rec xs = Cons (1, fun () -> Cons (2, fun () -> xs)) in
  take 5 xs
#+end_src

*** Enumerating the natural numbers
We've already seen the key idea, now we need to translate it to use =lazylist=.

#+begin_src ocaml
  let rec up_from n = Cons (n, fun () -> up_from (n + 1))

  let nats : int lazylist = up_from 0
#+end_src

#+begin_src ocaml :tangle no :exports both :results verbatim
  <<chp01-import>>
  take 10 nats
#+end_src

**** TODO Since I've organized laziness into its own chapter, maybe I should use OCaml's built-in Lazy library for the rest of the chapters? Cornell CS3110's streams using =Lazy.t= are much faster than those using =unit -> 'a=. :noexport:

** OCaml built-in Lazy
OCaml has a [[https://v2.ocaml.org/api/Lazy.html][built-in lazy library]], which also does "memoization". It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn't have to, it also avoids redoing work it has already done.

OCaml also has built-in library for delayed lists, [[https://v2.ocaml.org/api/Seq.html][Seq]]. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.

*** TODO Benchmark using Lazy.t vs using unit -> 'a. :noexport:
Also maybe benchmark using built-in Seq. Maybe I'll do a split like PearlCheck, where LeanCheck is a separate library written on its own. Idk if PearlCheck created LeanCheck though. But what I mean is maybe write self-contained posts to describe making a simple PBT library from scratch, then write my own using Seq and Lazy.t if they turn out to be better or for the sake of extra compatiblity and not remaking stuff.

Also noticed Seq.t is a deferred value in itself, which may make the type of interleave a bit more natural because it will be forced to be lazy when using the default Seq instead of adding laziness. Not a big change though.

Looks like there's already a Seq.interleave function that does what I need. So I think these may end up being just blog posts. Then will also write a library but may not bother doing literate programming for it, though I haven't decided yet. I do find literate programming interesting, and want to try it in a non-blog-post style.

There's also Seq.product for making tuples.

** Sources
I learned how lazy lists worked from the [[https://cs3110.github.io/textbook/chapters/ds/sequence.html][Cornell CS 3110 textbook]], and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.

* SnailCheck: Generating values by enumeration
:PROPERTIES:
:EXPORT_FILE_NAME: snailcheck_enumerating-types
:EXPORT_TITLE: SnailCheck: Enumerating types
:EXPORT_DATE: 2023-06-07
:EXPORT_HUGO_DRAFT: true
:header-args: :tangle 02/chapter-02.ml :noweb strip-export :results verbatim
:END:

** :noexport:
#+name: chp02-import
#+begin_src ocaml :tangle no
  #use "01/chapter-01.ml";;
  #use "02/chapter-02.ml";;
#+end_src

#+name: chp02-extra
#+begin_src ocaml :tangle no
  <<chp02-import>>
  #use "02/extra.ml";;
#+end_src

** 
[[file:/posts/snailcheck_laziness-from-scratch-in-ocaml][Previous post in this series]].

In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.

** Enumerating booleans
Enumerating booleans is simpler than the naturals, but it's worth seeing. We'll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.

#+begin_src ocaml
  let rec of_list xs =
    match xs with
    | [] -> Nil
    | x::xs -> Cons (x, fun () -> of_list xs)
#+end_src

#+begin_src ocaml
  let bool : bool lazylist = of_list [true; false]
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  take 2 bool
#+end_src

#+RESULTS:
: - : bool list = [true; false]

Note: We are doing some punning here to allow conciseness. [fn:pun] When used in types "bool" will still refer to the the standard boolean type. But when used in expressions "bool" means this particular lazy list.

[fn:pun] We're also doing punning because [[https://c-cube.github.io/qcheck/][QCheck]] does it that way, and we want to be compatible with QCheck.

** Enumerating integers
*** Problem
Listing the integers is non-obvious because unlike the naturals there is no "starting point". In math you can discuss the range \((-\infty, \infty)\), but we can't start at negative infinity.

OCaml's =int= type does technically have a starting point, =min_int=, which seems to be \(-2^{62}\). Maybe we could do =let int = up_from min_int=? There are a few problems with this:

1. For a while all you'll be seeing is negative numbers with a large magnitude. It's easier to work with smaller numbers, and we also want to check zero and positive numbers. One of the benefits of enumerative property-based testing is trying the simplest cases first---with random generation you tend to get huge test values that need to be "shrinked".
2. "a while" is probably longer than a human lifespan. Rough calculations with a 5 millisecond time per check gave me an 11-digit number of /years/. A quick Internet search says even just incrementing a counter from 0 to 2^{64} (not even checking properties) would take around 100 years.
3. Sometimes we may want to use a special integer type that can represent arbitrarily-large integers. Then there will be no such thing as =min_int=.

*** Solution
There is a way to arrange the integers that gives them a starting point and gives the simplest cases first: \(0, -1, 1, -2, 2, -3, 3, \ldots\) [fn:well-ordering]

We could express this as a single generator function like we did with the naturals:

#+begin_src ocaml :tangle no :exports both
  <<chp02-import>>
  let int : int lazylist =
    let rec ints' n =
      Cons (-n, fun () ->
               Cons (n, fun () -> ints' (n + 1))) in
    Cons (0, fun () -> ints' 1)
  ;;

  take 9 int
#+end_src

#+RESULTS:
: - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4]

However, we will express it in a way that I feel is more elegant. It will be useful to examine this technique with the integers first, because we will need it for more complex types later.

\[\mathbb{Z} = \mathbb{N} \cup \{-1, -2, -3, \ldots\}\]

We can break the integers into pieces. If we combine the natural numbers and the negative integers, we get the set of all integers.

The common way to combine lists is appending.

#+begin_src ocaml :tangle 02/extra.ml
  let rec append xs ys =
    match xs, ys with
    | Nil, ys -> ys
    | Cons (x, xs), ys ->
       Cons (x, fun () -> append (force xs) ys)
#+end_src

Let's confirm that our lazy list =append= works:

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  take 6 @@ append (of_list [1;2;3]) (of_list [4;5;6])
#+end_src

#+RESULTS:
: - : int list = [1; 2; 3; 4; 5; 6]

Now let's try making the integers:

#+begin_src ocaml
  let rec down_from n = Cons (n, fun () -> down_from (n - 1))
#+end_src

#+begin_src ocaml :tangle no :exports both
  <<chp02-extra>>
  let int = append nats (down_from (-1)) in
  take 9 @@ int
#+end_src

#+RESULTS:
: - : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8]

Oh no, we aren't seeing any negatives!

[fn:well-ordering] Apparently this is called the [[https://en.wikipedia.org/wiki/Well-order#Integers][well-ordering of the integers]]. I'd seen this ordering before, and I recently learned the Well-Ordering Principle, but hadn't seen this aspect. I'm glad to have learned this connection.

** TODO ? Enumerating algebraic data types (ADT)
This may go in chapter 3. Decide based on how long (how many words / estimated reading time) chapter 2 ends up being.

On the one hand, would be nice to put all the type enumeration together. On the other hand, it could be nice to have a short and sweet post that describes the problem with a non-lazy =interleave=.

** TODO If don't rely on previous chapter tangled code, maybe break this out into its own directory

** TODO ? Maybe add a link to the top of the previous post pointing to this post

* TODO SnailCheck: Upcoming

** TODO Show the recursive ADT ordering problem
When using =list= instead of =tiers=, when writing the definition for an ADT you must specify the non-recursive cases before the recursive cases, even with lazy =interleave=. Otherwise you get infinite recursion.

I'm not sure yet whether I want to describe how to fix this problem (and the unfair enumeration) with =tiers=, or if I just want to point people to PearlCheck.

*** TODO Mention that this occurs in Haskell/PearlCheck as well
I'm pretty sure PearlCheck doesn't mention/demonstrate it, but if you copy the code up to before =tiers= you get the same issue.

*** TODO If describe =tiers=, make sure we support mutually recursive types

** TODO Maybe: Restructuring to use =tiers= instead of =list=

** TODO Maybe: PBT functions
Stuff like LeanCheck or QuickCheck has.

- =exists= aka =search=
- =holds=
- =checkFor=

Not sure exactly what I'll want as I do want a QCheck-compatible interface.

** TODO Maybe: QCheck-compatible interface
Pretty sure I do want this in the library, but not sure if I want to cover it in the blog posts.

*** IDEA Combined QCheck and SnailCheck
Can have multiple tests in the same file that use one or the other based on which is best.

For example if you want an existence test, you'd use SnailCheck.

Then can also have a QCheck-compatible interface, so that you can just rename a module alias/import at the top of the file and switch all the QCheck-compatible (non existence, don't require enumeration) tests to SnailCheck or QCheck, back-and-forth with a one-line change.

