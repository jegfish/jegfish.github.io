<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SnailCheck: Laziness from scratch in OCaml | Jeffrey Fisher</title><meta name=keywords content="snailcheck,ocaml"><meta name=description content="Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.
I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck&rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips."><meta name=author content="Jeffrey Fisher"><link rel=canonical href=https://jeffreyfisher.net/posts/snailcheck_laziness-from-scratch-in-ocaml/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jeffreyfisher.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jeffreyfisher.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jeffreyfisher.net/favicon-32x32.png><link rel=apple-touch-icon href=https://jeffreyfisher.net/apple-touch-icon.png><link rel=mask-icon href=https://jeffreyfisher.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><meta property="og:title" content="SnailCheck: Laziness from scratch in OCaml"><meta property="og:description" content="Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.
I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck&rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips."><meta property="og:type" content="article"><meta property="og:url" content="https://jeffreyfisher.net/posts/snailcheck_laziness-from-scratch-in-ocaml/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-04T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-04T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SnailCheck: Laziness from scratch in OCaml"><meta name=twitter:description content="Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.
I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck&rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jeffreyfisher.net/posts/"},{"@type":"ListItem","position":2,"name":"SnailCheck: Laziness from scratch in OCaml","item":"https://jeffreyfisher.net/posts/snailcheck_laziness-from-scratch-in-ocaml/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SnailCheck: Laziness from scratch in OCaml","name":"SnailCheck: Laziness from scratch in OCaml","description":"Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck\u0026rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.","keywords":["snailcheck","ocaml"],"articleBody":" Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck’s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.\nOur first stop will be laziness.\nProperty-based testing (PBT) Later posts will give a better idea of what property-based testing is, but for now I’ll give a quick definition.\nA property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.\nFor example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.\nlet prop xs = xs = reverse (reverse xs) The PBT library would apply this function to many different lists, making sure that it evaluates to true each time.\nMotivation for laziness Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.\nMany types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.\nAttempt #1 at the natural numbers The natural numbers are \\(\\{0, 1, 2, 3, …\\}\\).\nThere is a pattern here: the “current” number is the previous number plus one.2 We repeatedly call the function fun n -\u003e n + 1 on the “current” number, then consider the result the new “current” number.\nLet’s list them out.\nlet rec nats n = n :: nats (n + 1);; nats 0 Stack overflow during evaluation (looping recursion?). There’s a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn’t have enough memory to store them.\nWe need to be lazy, to delay computation until later.3\nLaziness How do we represent computation without immediately evaluating it?\nFunctions! If you define a function with an infinite loop, it won’t actually freeze your program unless you call the function.\nWe will represent lazy values with the type unit -\u003e 'a, a function that takes one argument of type unit, and returns our value. unit is a special type that only has one value, which is also called “unit” and is written as empty paired parentheses, (). The argument to our lazy values carries no information, it’s more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.\ntype 't delayed = unit -\u003e 't A more standard name for “delayed” would be thunk.\nHere are some sample lazy values:\nlet a : int delayed = fun () -\u003e 42;; let b : int delayed = fun () -\u003e List.fold_left (+) 0 [1;2;3];; For readability we will write a function for evaluating lazy values, force.\nlet force lazy_val = lazy_val () sprintf \"%d\\n\" (force a) ^ sprintf \"%d\\n\" (force b);; 42 6 Attempt #2 at natural numbers let rec up_from n = n :: up_from (n + 1) let nats : int list delayed = fun () -\u003e up_from 0 We break out the implementation of nats into up_from.\nWe can now pass around the value nats without freezing, but if we try to unwrap the lazy value, we’ll still infinitely recurse. We’ve merely delayed a problematic expression, not fixed the problem.\nInstead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.\nWe want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.\nlet rec up_from n = n :: (fun () -\u003e up_from (n + 1)) Line 1, characters 25-52: 1 | let rec up_from n = n :: (fun () -\u003e up_from (n + 1));; ^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: This expression should not be a function, the expected type is 'a list This code is basically what we want, but we’ll need to create our own type to represent it.\nLazy lists type 'a lazylist = Nil | Cons of 'a * 'a lazylist delayed Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.\nSome example lazy lists:\nlet _ : 'a lazylist = Nil;; let _ : int lazylist = Cons (1, fun () -\u003e Nil);; let _ : string lazylist = Cons (\"a\", fun () -\u003e Cons (\"b\", fun () -\u003e Nil));; Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.\nInfinite: lazy lists Finite: lazy lists OR lists Lazy lists support both, so we always use them for the sake of uniformity.\nThe above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.\nlet rec int_range first last = if first \u003e last then Nil else Cons (first, fun () -\u003e int_range (first + 1) last) Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.\nlet one_to_twenty = int_range 1 20 To view lazy lists, we can grab the first few elements as a regular list.\n(* Returns a regular list of the first [n] elements of [ll]. If [n] greater than the length of [ll], returns [ll] as a regular list. *) let rec take n ll = if n = 0 then [] else ( match ll with | Nil -\u003e [] | Cons (x, xs) -\u003e x :: take (n - 1) (force xs) ) take 100 @@ int_range 1 20 Infinite lists The simplest infinite lists are just cycles.\nlet rec rocks name = Cons (name ^ \" rocks!\", fun () -\u003e rocks name) in take 3 @@ rocks \"Property-based testing\" It doesn’t have to be a function:\nlet rec xs = Cons (1, fun () -\u003e Cons (2, fun () -\u003e xs)) in take 5 xs Enumerating the natural numbers We’ve already seen the key idea, now we need to translate it to use lazylist.\nlet rec up_from n = Cons (n, fun () -\u003e up_from (n + 1)) let nats : int lazylist = up_from 0 take 10 nats OCaml built-in Lazy OCaml has a built-in lazy library, which also does “memoization”. It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn’t have to, it also avoids redoing work it has already done.\nFor the rest of the series I will use the built-in Lazy.t.\nOCaml also has built-in library for delayed lists, Seq. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.\nSources I learned how lazy lists worked from the Cornell CS 3110 textbook, and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.\nhttp://jmct.cc/pearlcheck.pdf\nSnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.\nIf you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won’t be covered in this series. ↩︎\nIn fact there is a representation of the natural numbers based on this fact, called the Peano numbers.\ntype peano = Z | S of peano Z = “zero”, S = “successor”.\nZero: Z One: S (Z) Two: S (S (Z)) ↩︎ Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.\nlet nats n = n : nats (n + 1) in let xs = nats 0 in take 10 xs [0,1,2,3,4,5,6,7,8,9] ↩︎ ","wordCount":"1467","inLanguage":"en","datePublished":"2023-06-04T00:00:00Z","dateModified":"2023-06-04T00:00:00Z","author":[{"@type":"Person","name":"Jeffrey Fisher"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jeffreyfisher.net/posts/snailcheck_laziness-from-scratch-in-ocaml/"},"publisher":{"@type":"Organization","name":"Jeffrey Fisher","logo":{"@type":"ImageObject","url":"https://jeffreyfisher.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jeffreyfisher.net/ accesskey=h title="Jeffrey Fisher (Alt + H)">Jeffrey Fisher</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jeffreyfisher.net/about/ title=About><span>About</span></a></li><li><a href=https://jeffreyfisher.net/posts/ title=Blog><span>Blog</span></a></li><li><a href=https://jeffreyfisher.net/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://jeffreyfisher.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SnailCheck: Laziness from scratch in OCaml</h1><div class=post-meta><span title='2023-06-04 00:00:00 +0000 UTC'>June 4, 2023</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Jeffrey Fisher</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#property-based-testing--pbt aria-label="Property-based testing (PBT)">Property-based testing (PBT)</a></li><li><a href=#motivation-for-laziness aria-label="Motivation for laziness">Motivation for laziness</a><ul><li><a href=#attempt-1-at-the-natural-numbers aria-label="Attempt #1 at the natural numbers">Attempt #1 at the natural numbers</a></li></ul></li><li><a href=#laziness aria-label=Laziness>Laziness</a><ul><li><a href=#attempt-2-at-natural-numbers aria-label="Attempt #2 at natural numbers">Attempt #2 at natural numbers</a></li></ul></li><li><a href=#lazy-lists aria-label="Lazy lists">Lazy lists</a></li><li><a href=#infinite-lists aria-label="Infinite lists">Infinite lists</a><ul><li><a href=#enumerating-the-natural-numbers aria-label="Enumerating the natural numbers">Enumerating the natural numbers</a></li></ul></li><li><a href=#ocaml-built-in-lazy aria-label="OCaml built-in Lazy">OCaml built-in Lazy</a></li><li><a href=#sources aria-label=Sources>Sources</a></li></ul></div></details></div><div class=post-content><h2 id=d41d8c><a hidden class=anchor aria-hidden=true href=#d41d8c>#</a></h2><p>Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.</p><p>I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> and <a href=https://hackage.haskell.org/package/leancheck>LeanCheck</a>. Like them, SnailCheck&rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.</p><p>Our first stop will be laziness.</p><h2 id=property-based-testing--pbt>Property-based testing (PBT)<a hidden class=anchor aria-hidden=true href=#property-based-testing--pbt>#</a></h2><p>Later posts will give a better idea of what property-based testing is, but for now I&rsquo;ll give a quick definition.</p><p>A property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.</p><p>For example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> prop xs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  xs <span style=color:#f92672>=</span> reverse <span style=color:#f92672>(</span>reverse xs<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The PBT library would apply this function to many different lists, making sure that it evaluates to <code>true</code> each time.</p><h2 id=motivation-for-laziness>Motivation for laziness<a hidden class=anchor aria-hidden=true href=#motivation-for-laziness>#</a></h2><p>Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.</p><p>Many types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.</p><h3 id=attempt-1-at-the-natural-numbers>Attempt #1 at the natural numbers<a hidden class=anchor aria-hidden=true href=#attempt-1-at-the-natural-numbers>#</a></h3><p>The natural numbers are \(\{0, 1, 2, 3, &mldr;\}\).</p><p>There is a pattern here: the &ldquo;current&rdquo; number is the previous number plus one.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> We repeatedly call the function <code>fun n -> n + 1</code> on the &ldquo;current&rdquo; number, then consider the result the new &ldquo;current&rdquo; number.</p><p>Let&rsquo;s list them out.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> nats n <span style=color:#f92672>=</span> n <span style=color:#f92672>::</span> nats <span style=color:#f92672>(</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span>nats 0
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Stack overflow during evaluation (looping recursion?).
</span></span></code></pre></div><p>There&rsquo;s a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn&rsquo;t have enough memory to store them.</p><p>We need to be lazy, to delay computation until later.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><h2 id=laziness>Laziness<a hidden class=anchor aria-hidden=true href=#laziness>#</a></h2><p>How do we represent computation without immediately evaluating it?</p><p>Functions! If you define a function with an infinite loop, it won&rsquo;t actually freeze your program unless you call the function.</p><p>We will represent lazy values with the type <code>unit -> 'a</code>, a function that takes one argument of type <code>unit</code>, and returns our value. <code>unit</code> is a special type that only has one value, which is also called &ldquo;unit&rdquo; and is written as empty paired parentheses, <code>()</code>. The argument to our lazy values carries no information, it&rsquo;s more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>t delayed <span style=color:#f92672>=</span> <span style=color:#66d9ef>unit</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>&#39;</span>t
</span></span></code></pre></div><p>A more standard name for &ldquo;delayed&rdquo; would be <a href=https://en.wikipedia.org/wiki/Thunk>thunk</a>.</p><p>Here are some sample lazy values:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> a <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> delayed <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> 42<span style=color:#f92672>;;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> b <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> delayed <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> List.fold_left <span style=color:#f92672>(+)</span> 0 <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>];;</span>
</span></span></code></pre></div><p>For readability we will write a function for evaluating lazy values, <code>force</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> force lazy_val <span style=color:#f92672>=</span> lazy_val ()
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>sprintf <span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>(</span>force a<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>^</span> sprintf <span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span> <span style=color:#f92672>(</span>force b<span style=color:#f92672>);;</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>42
</span></span><span style=display:flex><span>6
</span></span></code></pre></div><h3 id=attempt-2-at-natural-numbers>Attempt #2 at natural numbers<a hidden class=anchor aria-hidden=true href=#attempt-2-at-natural-numbers>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> up_from n <span style=color:#f92672>=</span> n <span style=color:#f92672>::</span> up_from <span style=color:#f92672>(</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> nats <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>list</span> delayed <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> up_from 0
</span></span></code></pre></div><p>We break out the implementation of <code>nats</code> into <code>up_from</code>.</p><p>We can now pass around the value <code>nats</code> without freezing, but if we try to unwrap the lazy value, we&rsquo;ll still infinitely recurse. We&rsquo;ve merely delayed a problematic expression, not fixed the problem.</p><p>Instead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.</p><p>We want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> up_from n <span style=color:#f92672>=</span> n <span style=color:#f92672>::</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> up_from <span style=color:#f92672>(</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Line 1, characters 25-52:
</span></span><span style=display:flex><span>1 | let rec up_from n = n :: (fun () -&gt; up_from (n + 1));;
</span></span><span style=display:flex><span>                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^
</span></span><span style=display:flex><span>Error: This expression should not be a function, the expected type is &#39;a list
</span></span></code></pre></div><p>This code is basically what we want, but we&rsquo;ll need to create our own type to represent it.</p><h2 id=lazy-lists>Lazy lists<a hidden class=anchor aria-hidden=true href=#lazy-lists>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a lazylist <span style=color:#f92672>=</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>*</span> <span style=color:#66d9ef>&#39;</span>a lazylist delayed
</span></span></code></pre></div><p>Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.</p><p>Some example lazy lists:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>_</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a lazylist <span style=color:#f92672>=</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>;;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>_</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> lazylist <span style=color:#f92672>=</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>);;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>_</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>string</span> lazylist <span style=color:#f92672>=</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;a&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span><span style=color:#e6db74>&#34;b&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>));;</span>
</span></span></code></pre></div><p>Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.</p><ul><li>Infinite: lazy lists</li><li>Finite: lazy lists OR lists</li></ul><p>Lazy lists support both, so we always use them for the sake of uniformity.</p><p>The above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> int_range first last <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> first <span style=color:#f92672>&gt;</span> last <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Nil</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>first<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> int_range <span style=color:#f92672>(</span>first <span style=color:#f92672>+</span> 1<span style=color:#f92672>)</span> last<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> one_to_twenty <span style=color:#f92672>=</span> int_range 1 20
</span></span></code></pre></div><p>To view lazy lists, we can grab the first few elements as a regular list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#75715e>(* Returns a regular list of the first [n] elements of [ll]. If [n] greater than
</span></span></span><span style=display:flex><span><span style=color:#75715e>   the length of [ll], returns [ll] as a regular list. *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> take n ll <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> n <span style=color:#f92672>=</span> 0 <span style=color:#66d9ef>then</span>
</span></span><span style=display:flex><span>    []
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> <span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> ll <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>-&gt;</span> []
</span></span><span style=display:flex><span>    <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span> x <span style=color:#f92672>::</span> take <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>force xs<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 100 <span style=color:#f92672>@@</span> int_range 1 20
</span></span></code></pre></div><h2 id=infinite-lists>Infinite lists<a hidden class=anchor aria-hidden=true href=#infinite-lists>#</a></h2><p>The simplest infinite lists are just cycles.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> rocks name <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>name <span style=color:#f92672>^</span> <span style=color:#e6db74>&#34; rocks!&#34;</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> rocks name<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>take 3 <span style=color:#f92672>@@</span> rocks <span style=color:#e6db74>&#34;Property-based testing&#34;</span>
</span></span></code></pre></div><p>It doesn&rsquo;t have to be a function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> xs <span style=color:#f92672>=</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>1<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>2<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> xs<span style=color:#f92672>))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>take 5 xs
</span></span></code></pre></div><h3 id=enumerating-the-natural-numbers>Enumerating the natural numbers<a hidden class=anchor aria-hidden=true href=#enumerating-the-natural-numbers>#</a></h3><p>We&rsquo;ve already seen the key idea, now we need to translate it to use <code>lazylist</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> up_from n <span style=color:#f92672>=</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> up_from <span style=color:#f92672>(</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> nats <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> lazylist <span style=color:#f92672>=</span> up_from 0
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 nats
</span></span></code></pre></div><h2 id=ocaml-built-in-lazy>OCaml built-in Lazy<a hidden class=anchor aria-hidden=true href=#ocaml-built-in-lazy>#</a></h2><p>OCaml has a <a href=https://v2.ocaml.org/api/Lazy.html>built-in lazy library</a>, which also does &ldquo;memoization&rdquo;. It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn&rsquo;t have to, it also avoids redoing work it has already done.</p><p>For the rest of the series I will use the built-in <code>Lazy.t</code>.</p><p>OCaml also has built-in library for delayed lists, <a href=https://v2.ocaml.org/api/Seq.html>Seq</a>. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.</p><h2 id=sources>Sources<a hidden class=anchor aria-hidden=true href=#sources>#</a></h2><p>I learned how lazy lists worked from the <a href=https://cs3110.github.io/textbook/chapters/ds/sequence.html>Cornell CS 3110 textbook</a>, and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=http://jmct.cc/pearlcheck.pdf>http://jmct.cc/pearlcheck.pdf</a></p><p>SnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.</p><p>If you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won&rsquo;t be covered in this series.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>In fact there is a representation of the natural numbers based on this fact, called the Peano numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> peano <span style=color:#f92672>=</span> <span style=color:#a6e22e>Z</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>S</span> <span style=color:#66d9ef>of</span> peano
</span></span></code></pre></div><p>Z = &ldquo;zero&rdquo;, S = &ldquo;successor&rdquo;.</p><ul><li>Zero: <span class="inline-src language-ocaml" data-lang=ocaml><code>Z</code></span></li><li>One: <span class="inline-src language-ocaml" data-lang=ocaml><code>S (Z)</code></span></li><li>Two: <span class="inline-src language-ocaml" data-lang=ocaml><code>S (S (Z))</code></span></li></ul>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li><li id=fn:3><p>Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>let</span> nats n <span style=color:#f92672>=</span> n <span style=color:#66d9ef>:</span> nats (n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> xs <span style=color:#f92672>=</span> nats <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>take</span> <span style=color:#ae81ff>10</span> xs
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>[0,1,2,3,4,5,6,7,8,9]
</span></span></code></pre></div>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jeffreyfisher.net/tags/snailcheck/>snailcheck</a></li><li><a href=https://jeffreyfisher.net/tags/ocaml/>ocaml</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jeffreyfisher.net/>Jeffrey Fisher</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>