<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SnailCheck: Enumerating types | Jeffrey Fisher</title><meta name=keywords content="snailcheck,ocaml"><meta name=description content="Previous post in this series.
In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.
Enumerating booleans Enumerating booleans is simpler than the naturals, but it&rsquo;s worth seeing. We&rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.
let rec of_list xs = match xs with | [] -> Nil | x::xs -> Cons (x, fun () -> of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness."><meta name=author content="Jeffrey Fisher"><link rel=canonical href=https://jeffreyfisher.net/posts/snailcheck-enum/><link crossorigin=anonymous href=/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jeffreyfisher.net/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jeffreyfisher.net/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jeffreyfisher.net/favicon-32x32.png><link rel=apple-touch-icon href=https://jeffreyfisher.net/apple-touch-icon.png><link rel=mask-icon href=https://jeffreyfisher.net/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><meta property="og:title" content="SnailCheck: Enumerating types"><meta property="og:description" content="Previous post in this series.
In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.
Enumerating booleans Enumerating booleans is simpler than the naturals, but it&rsquo;s worth seeing. We&rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.
let rec of_list xs = match xs with | [] -> Nil | x::xs -> Cons (x, fun () -> of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness."><meta property="og:type" content="article"><meta property="og:url" content="https://jeffreyfisher.net/posts/snailcheck-enum/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-08T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="SnailCheck: Enumerating types"><meta name=twitter:description content="Previous post in this series.
In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.
Enumerating booleans Enumerating booleans is simpler than the naturals, but it&rsquo;s worth seeing. We&rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.
let rec of_list xs = match xs with | [] -> Nil | x::xs -> Cons (x, fun () -> of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jeffreyfisher.net/posts/"},{"@type":"ListItem","position":2,"name":"SnailCheck: Enumerating types","item":"https://jeffreyfisher.net/posts/snailcheck-enum/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SnailCheck: Enumerating types","name":"SnailCheck: Enumerating types","description":"Previous post in this series.\nIn the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.\nEnumerating booleans Enumerating booleans is simpler than the naturals, but it\u0026rsquo;s worth seeing. We\u0026rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.\nlet rec of_list xs = match xs with | [] -\u0026gt; Nil | x::xs -\u0026gt; Cons (x, fun () -\u0026gt; of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness.","keywords":["snailcheck","ocaml"],"articleBody":" Previous post in this series.\nIn the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.\nEnumerating booleans Enumerating booleans is simpler than the naturals, but it’s worth seeing. We’ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.\nlet rec of_list xs = match xs with | [] -\u003e Nil | x::xs -\u003e Cons (x, fun () -\u003e of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness. 1 When used in types “bool” will still refer to the the standard boolean type. But when used in expressions “bool” means this particular lazy list.\nEnumerating integers Problem Listing the integers is non-obvious because unlike the naturals there is no “starting point”. In math you can discuss the range \\((-\\infty, \\infty)\\), but in code we can’t start at negative infinity.\nOCaml’s int type does technically have a starting point, min_int, which seems to be \\(-2^{62}\\). Maybe we could do let int = up_from min_int? There are a few problems with this:\nFor a while all you’ll be seeing is negative numbers with a large magnitude. It’s easier to work with smaller numbers, and we also want to check zero and positive numbers. It’s also nice to try the simplest cases first, to hopefully report a failure that is easy to understand. “a while” is probably longer than a human lifespan. Rough calculations with a 5 millisecond time per check gave me an 11-digit number of years. 5 ms is perhaps a long time for executing a function, but even at the nanosecond scale you can’t exhaust the integers. A quick Internet search says even just incrementing a counter from 0 to 264 (not even checking properties) would take around 100 years. Sometimes we may want to use a special integer type that can represent arbitrarily-large integers. Then there will be no such thing as min_int. Solution There is a way to arrange the integers that gives them a starting point and gives the simplest cases first: \\(0, -1, 1, -2, 2, -3, 3, \\ldots\\) 2\nWe could express this as a single generator function like we did with the naturals:\nlet int : int lazylist = let rec ints' n = Cons (-n, fun () -\u003e Cons (n, fun () -\u003e ints' (n + 1))) in Cons (0, fun () -\u003e ints' 1) ;; take 9 int - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4] However, we will express it in a way that I feel is more elegant. It will be useful to examine this technique with the integers first, because we will need it for more complex types later.\n\\[\\mathbb{Z} = \\mathbb{N} \\cup \\{-1, -2, -3, \\ldots\\}\\]\nWe can break the integers into pieces. If we combine the natural numbers and the negative integers, we get the set of all integers.\nThe common way to combine lists is appending.\nlet rec append xs ys = match xs, ys with | Nil, ys -\u003e ys | Cons (x, xs), ys -\u003e Cons (x, fun () -\u003e append (force xs) ys) Let’s confirm that our lazy list append works:\ntake 6 @@ append (of_list [1;2;3]) (of_list [4;5;6]) - : int list = [1; 2; 3; 4; 5; 6] Now let’s try making the integers:\nlet rec down_from n = Cons (n, fun () -\u003e down_from (n - 1)) let int = append nats (down_from (-1)) in take 9 int - : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8] Oh no, we aren’t seeing any negatives! There are infinitely many naturals, so we’ll never get to the negatives.\nIf we make a slight change to our append function, we can get the behavior we want.\nlet rec interleave xs ys = match xs, ys with | Nil, ys -\u003e ys | Cons (x, xs), ys -\u003e Cons (x, fun () -\u003e interleave ys (force xs)) (* Difference: append (force xs) ys *) (* Operator form. *) let ( @| ) = interleave let int : int lazylist = nats @| (down_from (-1)) In the recursive call we now swap the position of xs and ys, so we will get the behavior of alternating which list we grab from.\ntake 9 int - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4] Enumerating tuples Not all functions deal with simple scalar types. We also want to enumerate structured types, starting with tuples.\nFirst let’s add the ability to map over lazy lists.\nlet rec map f xs = match xs with | Nil -\u003e Nil | Cons (x, xs) -\u003e Cons (f x, fun () -\u003e map f (force xs)) let square x = x * x in let perfect_squares = map square nats in take 10 perfect_squares - : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81] let rec pair_with x ll = map (fun y -\u003e (x, y)) ll let rec pair xlist ylist = match xlist, ylist with | Cons (x, xrest), Cons (y, yrest) -\u003e (* x paired with every y, interleaved with: pair xs ylist *) Cons ((x,y), fun () -\u003e pair_with x (force yrest) @| pair (force xrest) ylist) | Nil, _ -\u003e Nil | _, Nil -\u003e Nil The key idea is to pair up the first x with every y in ylist, then combine that with the pairing of xrest with ylist.\nNote that pair_with x (force yrest) actually uses yrest, so it skips the first y. This is fine though because we have the pairing of x and the first y with Cons ((x,y), ...).\nThe Cons ((x,y), ...) piece is a bit inelegant, but necessary with the current implementation of interleave. Later we will solve this issue and clean up pair.\ntake 10 @@ pair_with 42 (of_list [1;2;3;4;5]) - : (int * int) list = [(42, 1); (42, 2); (42, 3); (42, 4); (42, 5)] take 10 @@ pair bool bool - : (bool * bool) list = [(true, true); (true, false); (false, true); (false, false)] take 10 @@ pair int int - : (int * int) list = [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2); (-1, 1); (0, -3)] We can of course mix different types.\ntake 10 @@ pair int bool - : (int * bool) list = [(0, true); (0, false); (-1, true); (-1, false); (1, true); (1, false); (-2, true); (-2, false); (2, true); (2, false)] Triples and n-tuples Two is a magic number. We can mimic n-tuples using nested pairs.\nFor example: (1, (2, 3)).\nlet triple xs ys zs = let triple_of_nest (a, (b, c)) = (a, b, c) in map triple_of_nest (pair xs (pair ys zs)) take 5 @@ triple int (pair bool int) int - : (int * (bool * int) * int) list = [(0, (true, 0), 0); (0, (true, 0), -1); (-1, (true, 0), 0); (0, (true, -1), 0); (-1, (true, 0), -1)] Enumerating algebraic data types (ADT) Here’s an interesting but still simple ADT: a binary tree.\ntype 'a tree = Leaf | Branch of 'a * 'a tree * 'a tree The enumeration of ADT constructors can be built directly off of tuple enumeration. We enumerate n-tuples, where n is the number of arguments to the constructor, then construct values.\nlet cons0 cons = of_list [cons] let cons1 cons a = map cons a let cons2 cons a b = map cons (pair a b) let cons3 cons a b c = map cons (triple a b c) In OCaml constructors cannot be passed around like functions, so we will define function wrappers to pass to consN.\nlet leaf = Leaf;; let branch (v, l, r) = Branch (v, l, r) The branch function converts an appropriate tuple into a tree branch.\nlet rec tree_a typ = cons0 leaf @| cons3 branch typ (tree_a typ) (tree_a typ) The type tree has two constructors. We start with the simple one, Leaf. It is a nullary constructor (no arguments), so we do cons0 leaf to enumerate it.\nThe other constructor is Branch, which has 3 parts, so we use cons3. The first part is of type 'a, the type the tree is parameterized by. We have the typ argument to take in the enumeration of 'a, so we do cons3 branch typ. The next two parts are both of type tree, so we have cons3 branch typ (tree_a typ) (tree_a typ).\nWriting enumerations of algebraic data types is a simple, mechanical process.3\nLet’s check out the result.\ntake 5 @@ (tree_a int) Stack overflow during evaluation (looping recursion?). Turns out I lied a bit. What went wrong?\nThe top level function in the body of tree_a is @| (a.k.a. interleave). OCaml uses strict evaluation, so we evaluate the arguments before evaluating the function. The left argument cons0 leaf is fine. The problem arises in the right argument, which has recursive calls to tree_a.\nWith recursion it is usually important to have:\nA base case. Recursive calls make the input “smaller”, approaching the base case. Conditional that checks whether to perform the base or recursive case. We have a base case of cons0 leaf, but we don’t have a conditional. Conditionals are special in that only some of their arguments/branches are evaluated each time, while functions have all of their arguments evaluated every time.\nThe problem is that we are always evaluating the recursive calls in cons3 branch typ (tree_a typ) (tree_a typ), so we recurse infinitely.\nSolution Imagine you are tree_a. This is roughly the behavior we want:\nFor the first tree, I’ll give you a Leaf. For the second tree, I’ll give you a Branch. To make a branch, I need to make a 'a. That’s easy, I use typ. I also need to make two of 'a tree. To do that, I make two nested calls of tree_a typ. I’m the first nested call. I’ll give you the first tree in the enumeration. That’s Leaf. I’m the second nested call. I’ll give you the first tree in the enumeration. That’s Leaf. I’ve completed giving Branch Leaf Leaf. For the third tree, … If we grab the base case (Leaf) first, we can manage to build recursive cases (Branch).\nWe can’t do this with strict evaluation, so we need to add a bit of laziness. We will write lazy_interleave so that its arguments are both lazy (delayed), so we won’t get stuck on recursive calls encountered while evaluating the arguments to lazy_interleave.4\nlet rec lazy_interleave (xs : 'a lazylist delayed) (ys: 'a lazylist delayed) = let xs = force xs in match xs with | Nil -\u003e force ys | Cons (x, xs) -\u003e Cons (x, fun () -\u003e lazy_interleave ys xs) let ( @|| ) = lazy_interleave Now we can enumerate trees.\nlet rec tree typ = let a = fun () -\u003e cons0 leaf in let b = fun () -\u003e cons3 branch typ (tree typ) (tree typ) in a @|| b in take 3 @@ tree int - : int tree list = [Leaf; Branch (0, Leaf, Leaf); Branch (0, Leaf, Branch (0, Leaf, Leaf))] Order matters Remember when I said we needed to grab the base case(s) before the recursive case(s)? With the current code, that’s true.\nlet rec tree_bad typ = let a = fun () -\u003e cons3 branch typ (tree_bad typ) (tree_bad typ) in let b = fun () -\u003e cons0 leaf in a @|| b in take 5 @@ tree_bad int Stack overflow during evaluation (looping recursion?). This is problematic. It’s annoying to remember and results in an unhelpful error message.5\nIt’s not simply a matter of laziness. PearlCheck, which is written in the lazy language Haskell, also faces this problem—though it is solved later in the paper.6\nIt is possible to solve this problem in SnailCheck if we switch from simple enumerated lists to tiers, like PearlCheck uses. That may be covered in a later post, but for now you can check out the PearlCheck paper.\nEnumerating lists Lists in OCaml are essentially an algebraic data type, so we can enumerate them now.\nlet rec list typ = let cons (x, xs) = x :: xs in (fun () -\u003e cons0 []) @|| (fun () -\u003e cons2 cons typ (list typ)) take 5 @@ list bool - : bool list list = [[]; [true]; [true; true]; [false]; [true; true; true]] Elegant pair As promised, here is the elegant version of pair. This eliminates the Cons ((x,y), ...) and expresses it only with pair_with and a recursive call.\nlet rec elegant_pair xlist ylist = match xlist, ylist with | Cons (x, xrest), Cons (y, yrest) -\u003e (* x paired with every y, then repeat with xrest. *) (fun () -\u003e pair_with x ylist) @|| (fun () -\u003e elegant_pair (force xrest) ylist) | Nil, _ -\u003e Nil | _, Nil -\u003e Nil take 10 @@ elegant_pair int int - : (int * int) list = [(0, 0); (-1, 0); (0, -1); (1, 0); (0, 1); (-1, -1); (0, -2); (-2, 0); (0, 2); (-1, 1)] take 10 @@ pair int int - : (int * int) list = [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2); (-1, 1); (0, -3)] The order is a bit different, but it’s still correct.\nSee also This may be the last SnailCheck post, so I’ll leave you with some pointers if you’re interested in learning more.\nAs mentioned previously this series is essentially a port of the PearlCheck paper to OCaml.\nPearlCheck is a “tutorial reconstruction” of LeanCheck: https://hackage.haskell.org/package/leancheck So far the SnailCheck posts have covered the parts I struggled to translate to OCaml, but there is a lot more covered by PearlCheck that’s worth reading. According to PearlCheck, SmallCheck was the first enumerative PBT tool for Haskell.\nPaper: https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf An implementation: https://github.com/Bodigrim/smallcheck Feat: functional enumeration of algebraic types\nPaper: https://dl.acm.org/doi/abs/10.1145/2364506.2364515 “Feat provides efficient ‘random access’ to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck)” An OCaml library inspired by Feat: https://gitlab.inria.fr/fpottier/feat/ There are a variety of testing frameworks for OCaml. Several of them support some form of property-based testing.\nhttps://ocamlverse.net/content/testing.html We’re also doing punning because QCheck does it that way, and we want to be compatible with QCheck. ↩︎\nApparently this is called the well-ordering of the integers. I’d seen this ordering before, and I recently learned the Well-Ordering Principle, but hadn’t made the connection until looking it up just now. ↩︎\nThat means we can automate the generation of enumerations of algebraic data types! I may write a post about this in the future. ↩︎\nThere’s not much use in keeping the non-lazy version of interleave around; I consider it broken. I only gave lazy_interleave a new name as a shortcut to appease the literate programming setup I’m using. ↩︎\nIf you know of a way to detect the problem and provide a helpful error message, let me know!\nMaybe stack overflow is a catchable exception, and could print an error message that suggests that the problem could be the order of the ADT cases. However, I say “suggest” because there could be other reasons for stack overflow; this merely detects a symptom rather than the problem.\nI’m thinking proper detection would require some sort of static analysis. Maybe it could be done with a PPX. ↩︎\nPearlCheck doesn’t mention this problem, but if you copy the code up through “Mark II: Algebraic Datatypes” you can reproduce the problem on this example:\ninstance Listable Expr where -- Different from the one in the paper. -- Recursive case comes first / on the left. list = cons2 Add \\/ cons1 Val -- Gets stuck here on infinite recursion. take 5 (list :: [Expr]) The error goes away at “Mark IV: Fair Enumeration” because of the swap from list to tiers. ↩︎\n","wordCount":"2705","inLanguage":"en","datePublished":"2023-06-08T00:00:00Z","dateModified":"2023-06-08T00:00:00Z","author":[{"@type":"Person","name":"Jeffrey Fisher"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://jeffreyfisher.net/posts/snailcheck-enum/"},"publisher":{"@type":"Organization","name":"Jeffrey Fisher","logo":{"@type":"ImageObject","url":"https://jeffreyfisher.net/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jeffreyfisher.net/ accesskey=h title="Jeffrey Fisher (Alt + H)">Jeffrey Fisher</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jeffreyfisher.net/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://jeffreyfisher.net/archive/ title=Archive><span>Archive</span></a></li><li><a href=https://jeffreyfisher.net/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://jeffreyfisher.net/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>SnailCheck: Enumerating types</h1><div class=post-meta><span title='2023-06-08 00:00:00 +0000 UTC'>June 8, 2023</span>&nbsp;·&nbsp;13 min&nbsp;·&nbsp;Jeffrey Fisher</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#enumerating-booleans aria-label="Enumerating booleans">Enumerating booleans</a></li><li><a href=#enumerating-integers aria-label="Enumerating integers">Enumerating integers</a><ul><li><a href=#problem aria-label=Problem>Problem</a></li><li><a href=#solution aria-label=Solution>Solution</a></li></ul></li><li><a href=#enumerating-tuples aria-label="Enumerating tuples">Enumerating tuples</a><ul><li><a href=#triples-and-n-tuples aria-label="Triples and n-tuples">Triples and n-tuples</a></li></ul></li><li><a href=#enumerating-algebraic-data-types--adt aria-label="Enumerating algebraic data types (ADT)">Enumerating algebraic data types (ADT)</a><ul><li><a href=#solution aria-label=Solution>Solution</a></li><li><a href=#order-matters aria-label="Order matters">Order matters</a></li></ul></li><li><a href=#enumerating-lists aria-label="Enumerating lists">Enumerating lists</a></li><li><a href=#elegant-pair aria-label="Elegant pair">Elegant <code>pair</code></a></li><li><a href=#see-also aria-label="See also">See also</a></li></ul></div></details></div><div class=post-content><h2 id=d41d8c><a hidden class=anchor aria-hidden=true href=#d41d8c>#</a></h2><p><a href=/posts/snailcheck-lazy>Previous post in this series</a>.</p><p>In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.</p><h2 id=enumerating-booleans>Enumerating booleans<a hidden class=anchor aria-hidden=true href=#enumerating-booleans>#</a></h2><p>Enumerating booleans is simpler than the naturals, but it&rsquo;s worth seeing. We&rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> of_list xs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xs <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> [] <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> x<span style=color:#f92672>::</span>xs <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> of_list xs<span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>bool</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>bool</span> lazylist <span style=color:#f92672>=</span> of_list <span style=color:#f92672>[</span>true<span style=color:#f92672>;</span> false<span style=color:#f92672>]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 2 <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : bool list = [true; false]
</span></span></code></pre></div><p>Note: We are doing some punning here to allow conciseness. <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> When used in types &ldquo;bool&rdquo; will still refer to the the standard boolean type. But when used in expressions &ldquo;bool&rdquo; means this particular lazy list.</p><h2 id=enumerating-integers>Enumerating integers<a hidden class=anchor aria-hidden=true href=#enumerating-integers>#</a></h2><h3 id=problem>Problem<a hidden class=anchor aria-hidden=true href=#problem>#</a></h3><p>Listing the integers is non-obvious because unlike the naturals there is no &ldquo;starting point&rdquo;. In math you can discuss the range \((-\infty, \infty)\), but in code we can&rsquo;t start at negative infinity.</p><p>OCaml&rsquo;s <code>int</code> type does technically have a starting point, <code>min_int</code>, which seems to be \(-2^{62}\). Maybe we could do <code>let int = up_from min_int</code>? There are a few problems with this:</p><ol><li>For a while all you&rsquo;ll be seeing is negative numbers with a large magnitude. It&rsquo;s easier to work with smaller numbers, and we also want to check zero and positive numbers. It&rsquo;s also nice to try the simplest cases first, to hopefully report a failure that is easy to understand.</li><li>&ldquo;a while&rdquo; is probably longer than a human lifespan. Rough calculations with a 5 millisecond time per check gave me an 11-digit number of <em>years</em>. 5 ms is perhaps a long time for executing a function, but even at the nanosecond scale you can&rsquo;t exhaust the integers. A quick Internet search says even just incrementing a counter from 0 to 2<sup>64</sup> (not even checking properties) would take around 100 years.</li><li>Sometimes we may want to use a special integer type that can represent arbitrarily-large integers. Then there will be no such thing as <code>min_int</code>.</li></ol><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>There is a way to arrange the integers that gives them a starting point and gives the simplest cases first: \(0, -1, 1, -2, 2, -3, 3, \ldots\) <sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><p>We could express this as a single generator function like we did with the naturals:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> lazylist <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> ints&#39; n <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(-</span>n<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>             <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> ints&#39; <span style=color:#f92672>(</span>n <span style=color:#f92672>+</span> 1<span style=color:#f92672>)))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>0<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> ints&#39; 1<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>;;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>take 9 <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4]
</span></span></code></pre></div><p>However, we will express it in a way that I feel is more elegant. It will be useful to examine this technique with the integers first, because we will need it for more complex types later.</p><p>\[\mathbb{Z} = \mathbb{N} \cup \{-1, -2, -3, \ldots\}\]</p><p>We can break the integers into pieces. If we combine the natural numbers and the negative integers, we get the set of all integers.</p><p>The common way to combine lists is appending.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> append xs ys <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xs<span style=color:#f92672>,</span> ys <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>,</span> ys <span style=color:#f92672>-&gt;</span> ys
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>),</span> ys <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> append <span style=color:#f92672>(</span>force xs<span style=color:#f92672>)</span> ys<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>Let&rsquo;s confirm that our lazy list <code>append</code> works:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 6 <span style=color:#f92672>@@</span> append <span style=color:#f92672>(</span>of_list <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>])</span> <span style=color:#f92672>(</span>of_list <span style=color:#f92672>[</span>4<span style=color:#f92672>;</span>5<span style=color:#f92672>;</span>6<span style=color:#f92672>])</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int list = [1; 2; 3; 4; 5; 6]
</span></span></code></pre></div><p>Now let&rsquo;s try making the integers:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> down_from n <span style=color:#f92672>=</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>n<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> down_from <span style=color:#f92672>(</span>n <span style=color:#f92672>-</span> 1<span style=color:#f92672>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>=</span> append nats <span style=color:#f92672>(</span>down_from <span style=color:#f92672>(-</span>1<span style=color:#f92672>))</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>take 9 <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8]
</span></span></code></pre></div><p>Oh no, we aren&rsquo;t seeing any negatives! There are infinitely many naturals, so we&rsquo;ll never get to the negatives.</p><p>If we make a slight change to our <code>append</code> function, we can get the behavior we want.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> interleave xs ys <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xs<span style=color:#f92672>,</span> ys <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>,</span> ys <span style=color:#f92672>-&gt;</span> ys
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>),</span> ys <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> interleave ys <span style=color:#f92672>(</span>force xs<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>         <span style=color:#75715e>(* Difference: append (force xs) ys *)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>(* Operator form. *)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span> <span style=color:#f92672>@|</span> <span style=color:#f92672>)</span> <span style=color:#f92672>=</span> interleave
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>int</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>int</span> lazylist <span style=color:#f92672>=</span> nats <span style=color:#f92672>@|</span> <span style=color:#f92672>(</span>down_from <span style=color:#f92672>(-</span>1<span style=color:#f92672>))</span>
</span></span></code></pre></div><p>In the recursive call we now swap the position of <code>xs</code> and <code>ys</code>, so we will get the behavior of alternating which list we grab from.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 9 <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4]
</span></span></code></pre></div><h2 id=enumerating-tuples>Enumerating tuples<a hidden class=anchor aria-hidden=true href=#enumerating-tuples>#</a></h2><p>Not all functions deal with simple scalar types. We also want to enumerate structured types, starting with tuples.</p><p>First let&rsquo;s add the ability to map over lazy lists.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> map f xs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xs <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>f x<span style=color:#f92672>,</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> map f <span style=color:#f92672>(</span>force xs<span style=color:#f92672>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> square x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> x <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> perfect_squares <span style=color:#f92672>=</span> map square nats <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>take 10 perfect_squares
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> pair_with x ll <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  map <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> y <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> y<span style=color:#f92672>))</span> ll
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> pair xlist ylist <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xlist<span style=color:#f92672>,</span> ylist <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xrest<span style=color:#f92672>),</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>y<span style=color:#f92672>,</span> yrest<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>(* x paired with every y, interleaved with: pair xs ylist *)</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>((</span>x<span style=color:#f92672>,</span>y<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> pair_with x <span style=color:#f92672>(</span>force yrest<span style=color:#f92672>)</span> <span style=color:#f92672>@|</span> pair <span style=color:#f92672>(</span>force xrest<span style=color:#f92672>)</span> ylist<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>,</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#f92672>_,</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span></code></pre></div><p>The key idea is to pair up the first <code>x</code> with every <code>y</code> in <code>ylist</code>, then combine that with the pairing of <code>xrest</code> with <code>ylist</code>.</p><p>Note that <code>pair_with x (force yrest)</code> actually uses <code>yrest</code>, so it skips the first <code>y</code>. This is fine though because we have the pairing of <code>x</code> and the first <code>y</code> with <code>Cons ((x,y), ...)</code>.</p><p>The <code>Cons ((x,y), ...)</code> piece is a bit inelegant, but necessary with the current implementation of <code>interleave</code>. Later we will solve this issue and clean up <code>pair</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> pair_with 42 <span style=color:#f92672>(</span>of_list <span style=color:#f92672>[</span>1<span style=color:#f92672>;</span>2<span style=color:#f92672>;</span>3<span style=color:#f92672>;</span>4<span style=color:#f92672>;</span>5<span style=color:#f92672>])</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * int) list = [(42, 1); (42, 2); (42, 3); (42, 4); (42, 5)]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> pair <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (bool * bool) list =
</span></span><span style=display:flex><span>[(true, true); (true, false); (false, true); (false, false)]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> pair <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * int) list =
</span></span><span style=display:flex><span>[(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2);
</span></span><span style=display:flex><span> (-1, 1); (0, -3)]
</span></span></code></pre></div><p>We can of course mix different types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> pair <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * bool) list =
</span></span><span style=display:flex><span>[(0, true); (0, false); (-1, true); (-1, false); (1, true); (1, false);
</span></span><span style=display:flex><span> (-2, true); (-2, false); (2, true); (2, false)]
</span></span></code></pre></div><h3 id=triples-and-n-tuples>Triples and n-tuples<a hidden class=anchor aria-hidden=true href=#triples-and-n-tuples>#</a></h3><p>Two is a magic number. We can mimic n-tuples using nested pairs.</p><p>For example: <code>(1, (2, 3))</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> triple xs ys zs <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> triple_of_nest <span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> <span style=color:#f92672>(</span>b<span style=color:#f92672>,</span> c<span style=color:#f92672>))</span> <span style=color:#f92672>=</span> <span style=color:#f92672>(</span>a<span style=color:#f92672>,</span> b<span style=color:#f92672>,</span> c<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  map triple_of_nest <span style=color:#f92672>(</span>pair xs <span style=color:#f92672>(</span>pair ys zs<span style=color:#f92672>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 5 <span style=color:#f92672>@@</span> triple <span style=color:#66d9ef>int</span> <span style=color:#f92672>(</span>pair <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * (bool * int) * int) list =
</span></span><span style=display:flex><span>[(0, (true, 0), 0); (0, (true, 0), -1); (-1, (true, 0), 0);
</span></span><span style=display:flex><span> (0, (true, -1), 0); (-1, (true, 0), -1)]
</span></span></code></pre></div><h2 id=enumerating-algebraic-data-types--adt>Enumerating algebraic data types (ADT)<a hidden class=anchor aria-hidden=true href=#enumerating-algebraic-data-types--adt>#</a></h2><p>Here&rsquo;s an interesting but still simple ADT: a binary tree.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>&#39;</span>a tree <span style=color:#f92672>=</span> <span style=color:#a6e22e>Leaf</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Branch</span> <span style=color:#66d9ef>of</span> <span style=color:#66d9ef>&#39;</span>a <span style=color:#f92672>*</span> <span style=color:#66d9ef>&#39;</span>a tree <span style=color:#f92672>*</span> <span style=color:#66d9ef>&#39;</span>a tree
</span></span></code></pre></div><p>The enumeration of ADT constructors can be built directly off of tuple enumeration. We enumerate n-tuples, where n is the number of arguments to the constructor, then construct values.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> cons0 cons <span style=color:#f92672>=</span> of_list <span style=color:#f92672>[</span>cons<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> cons1 cons a <span style=color:#f92672>=</span> map cons a
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> cons2 cons a b <span style=color:#f92672>=</span> map cons <span style=color:#f92672>(</span>pair a b<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> cons3 cons a b c <span style=color:#f92672>=</span> map cons <span style=color:#f92672>(</span>triple a b c<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>In OCaml constructors cannot be passed around like functions, so we will define function wrappers to pass to <code>consN</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> leaf <span style=color:#f92672>=</span> <span style=color:#a6e22e>Leaf</span><span style=color:#f92672>;;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> branch <span style=color:#f92672>(</span>v<span style=color:#f92672>,</span> l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Branch</span> <span style=color:#f92672>(</span>v<span style=color:#f92672>,</span> l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The <code>branch</code> function converts an appropriate tuple into a tree branch.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> tree_a typ <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  cons0 leaf
</span></span><span style=display:flex><span>  <span style=color:#f92672>@|</span> cons3 branch typ <span style=color:#f92672>(</span>tree_a typ<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>tree_a typ<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>The type <code>tree</code> has two constructors. We start with the simple one, <code>Leaf</code>. It is a nullary constructor (no arguments), so we do <code>cons0 leaf</code> to enumerate it.</p><p>The other constructor is <code>Branch</code>, which has 3 parts, so we use <code>cons3</code>. The first part is of type <code>'a</code>, the type the tree is parameterized by. We have the <code>typ</code> argument to take in the enumeration of <code>'a</code>, so we do <code>cons3 branch typ</code>. The next two parts are both of type tree, so we have <code>cons3 branch typ (tree_a typ) (tree_a typ)</code>.</p><p>Writing enumerations of algebraic data types is a simple, mechanical process.<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></p><p>Let&rsquo;s check out the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 5 <span style=color:#f92672>@@</span> <span style=color:#f92672>(</span>tree_a <span style=color:#66d9ef>int</span><span style=color:#f92672>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Stack overflow during evaluation (looping recursion?).
</span></span></code></pre></div><p>Turns out I lied a bit. What went wrong?</p><p>The top level function in the body of <code>tree_a</code> is <code>@|</code> (a.k.a. <code>interleave</code>). OCaml uses <a href=https://en.wikipedia.org/wiki/Strict_programming_language>strict evaluation</a>, so we evaluate the arguments before evaluating the function. The left argument <code>cons0 leaf</code> is fine. The problem arises in the right argument, which has recursive calls to <code>tree_a</code>.</p><p>With recursion it is usually important to have:</p><ol><li>A base case.</li><li>Recursive calls make the input &ldquo;smaller&rdquo;, approaching the base case.</li><li>Conditional that checks whether to perform the base or recursive case.</li></ol><p>We have a base case of <code>cons0 leaf</code>, but we don&rsquo;t have a conditional. Conditionals are special in that only some of their arguments/branches are evaluated each time, while functions have <strong>all</strong> of their arguments evaluated every time.</p><p>The problem is that we are always evaluating the recursive calls in <code>cons3 branch typ (tree_a typ) (tree_a typ)</code>, so we recurse infinitely.</p><h3 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h3><p>Imagine you are <code>tree_a</code>. This is roughly the behavior we want:</p><ul><li>For the first tree, I&rsquo;ll give you a <code>Leaf</code>.</li><li>For the second tree, I&rsquo;ll give you a <code>Branch</code>.<ul><li>To make a branch, I need to make a <code>'a</code>. That&rsquo;s easy, I use <code>typ</code>.</li><li>I also need to make two of <code>'a tree</code>. To do that, I make two nested calls of <code>tree_a typ</code>.<ul><li>I&rsquo;m the first nested call. I&rsquo;ll give you the first tree in the enumeration. That&rsquo;s <code>Leaf</code>.</li><li>I&rsquo;m the second nested call. I&rsquo;ll give you the first tree in the enumeration. That&rsquo;s <code>Leaf</code>.</li></ul></li><li>I&rsquo;ve completed giving <code>Branch Leaf Leaf</code>.</li></ul></li><li>For the third tree, &mldr;</li></ul><p>If we grab the base case (<code>Leaf</code>) first, we can manage to build recursive cases (<code>Branch</code>).</p><p>We can&rsquo;t do this with strict evaluation, so we need to add a bit of laziness. We will write <code>lazy_interleave</code> so that its arguments are both lazy (<code>delayed</code>), so we won&rsquo;t get stuck on recursive calls encountered while evaluating the arguments to <code>lazy_interleave</code>.<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> lazy_interleave <span style=color:#f92672>(</span>xs <span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a lazylist delayed<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>ys<span style=color:#f92672>:</span> <span style=color:#66d9ef>&#39;</span>a lazylist delayed<span style=color:#f92672>)</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> xs <span style=color:#f92672>=</span> force xs <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xs <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>-&gt;</span> force ys
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> lazy_interleave ys xs<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#f92672>(</span> <span style=color:#f92672>@||</span> <span style=color:#f92672>)</span> <span style=color:#f92672>=</span> lazy_interleave
</span></span></code></pre></div><p>Now we can enumerate trees.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> tree typ <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons0 leaf <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons3 branch typ <span style=color:#f92672>(</span>tree typ<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>tree typ<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  a <span style=color:#f92672>@||</span> b
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>take 3 <span style=color:#f92672>@@</span> tree <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : int tree list =
</span></span><span style=display:flex><span>[Leaf; Branch (0, Leaf, Leaf); Branch (0, Leaf, Branch (0, Leaf, Leaf))]
</span></span></code></pre></div><h3 id=order-matters>Order matters<a hidden class=anchor aria-hidden=true href=#order-matters>#</a></h3><p>Remember when I said we needed to grab the base case(s) before the recursive case(s)? With the current code, that&rsquo;s true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> tree_bad typ <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons3 branch typ <span style=color:#f92672>(</span>tree_bad typ<span style=color:#f92672>)</span> <span style=color:#f92672>(</span>tree_bad typ<span style=color:#f92672>)</span> <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> <span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons0 leaf <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  a <span style=color:#f92672>@||</span> b
</span></span><span style=display:flex><span><span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>take 5 <span style=color:#f92672>@@</span> tree_bad <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Stack overflow during evaluation (looping recursion?).
</span></span></code></pre></div><p>This is problematic. It&rsquo;s annoying to remember and results in an unhelpful error message.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><p>It&rsquo;s not simply a matter of laziness. <a href=http://jmct.cc/pearlcheck.pdf>PearlCheck</a>, which is written in the lazy language Haskell, also faces this problem&mdash;though it is solved later in the paper.<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup></p><p>It is possible to solve this problem in SnailCheck if we switch from simple enumerated lists to <code>tiers</code>, like PearlCheck uses. That may be covered in a later post, but for now you can check out the PearlCheck paper.</p><h2 id=enumerating-lists>Enumerating lists<a hidden class=anchor aria-hidden=true href=#enumerating-lists>#</a></h2><p>Lists in OCaml are essentially an algebraic data type, so we can enumerate them now.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> <span style=color:#66d9ef>list</span> typ <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> cons <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xs<span style=color:#f92672>)</span> <span style=color:#f92672>=</span> x <span style=color:#f92672>::</span> xs <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons0 []<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>@||</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> cons2 cons typ <span style=color:#f92672>(</span><span style=color:#66d9ef>list</span> typ<span style=color:#f92672>))</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 5 <span style=color:#f92672>@@</span> <span style=color:#66d9ef>list</span> <span style=color:#66d9ef>bool</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : bool list list = [[]; [true]; [true; true]; [false]; [true; true; true]]
</span></span></code></pre></div><h2 id=elegant-pair>Elegant <code>pair</code><a hidden class=anchor aria-hidden=true href=#elegant-pair>#</a></h2><p>As promised, here is the elegant version of <code>pair</code>. This eliminates the <code>Cons ((x,y), ...)</code> and expresses it only with <code>pair_with</code> and a recursive call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>rec</span> elegant_pair xlist ylist <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> xlist<span style=color:#f92672>,</span> ylist <span style=color:#66d9ef>with</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>x<span style=color:#f92672>,</span> xrest<span style=color:#f92672>),</span> <span style=color:#a6e22e>Cons</span> <span style=color:#f92672>(</span>y<span style=color:#f92672>,</span> yrest<span style=color:#f92672>)</span> <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>     <span style=color:#75715e>(* x paired with every y, then repeat with xrest. *)</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> pair_with x ylist<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>@||</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>fun</span> () <span style=color:#f92672>-&gt;</span> elegant_pair <span style=color:#f92672>(</span>force xrest<span style=color:#f92672>)</span> ylist<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>,</span> <span style=color:#f92672>_</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>|</span> <span style=color:#f92672>_,</span> <span style=color:#a6e22e>Nil</span> <span style=color:#f92672>-&gt;</span> <span style=color:#a6e22e>Nil</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> elegant_pair <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * int) list =
</span></span><span style=display:flex><span>[(0, 0); (-1, 0); (0, -1); (1, 0); (0, 1); (-1, -1); (0, -2); (-2, 0);
</span></span><span style=display:flex><span> (0, 2); (-1, 1)]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ocaml data-lang=ocaml><span style=display:flex><span>
</span></span><span style=display:flex><span>take 10 <span style=color:#f92672>@@</span> pair <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>int</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>- : (int * int) list =
</span></span><span style=display:flex><span>[(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2);
</span></span><span style=display:flex><span> (-1, 1); (0, -3)]
</span></span></code></pre></div><p>The order is a bit different, but it&rsquo;s still correct.</p><h2 id=see-also>See also<a hidden class=anchor aria-hidden=true href=#see-also>#</a></h2><p>This may be the last SnailCheck post, so I&rsquo;ll leave you with some pointers if you&rsquo;re interested in learning more.</p><ul><li><p>As mentioned previously this series is essentially a port of the <a href=http://jmct.cc/pearlcheck.pdf>PearlCheck</a> paper to OCaml.</p><ul><li>PearlCheck is a &ldquo;tutorial reconstruction&rdquo; of LeanCheck: <a href=https://hackage.haskell.org/package/leancheck>https://hackage.haskell.org/package/leancheck</a></li><li>So far the SnailCheck posts have covered the parts I struggled to translate to OCaml, but there is a lot more covered by PearlCheck that&rsquo;s worth reading.</li></ul></li><li><p>According to PearlCheck, SmallCheck was the first enumerative PBT tool for Haskell.</p><ul><li>Paper: <a href=https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf>https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf</a></li><li>An implementation: <a href=https://github.com/Bodigrim/smallcheck>https://github.com/Bodigrim/smallcheck</a></li></ul></li><li><p>Feat: functional enumeration of algebraic types</p><ul><li>Paper: <a href=https://dl.acm.org/doi/abs/10.1145/2364506.2364515>https://dl.acm.org/doi/abs/10.1145/2364506.2364515</a><ul><li>&ldquo;Feat provides efficient &lsquo;random access&rsquo; to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck)&rdquo;</li></ul></li><li>An OCaml library inspired by Feat: <a href=https://gitlab.inria.fr/fpottier/feat/>https://gitlab.inria.fr/fpottier/feat/</a></li></ul></li><li><p>There are a variety of testing frameworks for OCaml. Several of them support some form of property-based testing.</p><ul><li><a href=https://ocamlverse.net/content/testing.html>https://ocamlverse.net/content/testing.html</a></li></ul></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>We&rsquo;re also doing punning because <a href=https://c-cube.github.io/qcheck/>QCheck</a> does it that way, and we want to be compatible with QCheck.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Apparently this is called the <a href=https://en.wikipedia.org/wiki/Well-order#Integers>well-ordering of the integers</a>. I&rsquo;d seen this ordering before, and I recently learned the Well-Ordering Principle, but hadn&rsquo;t made the connection until looking it up just now.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>That means we can automate the generation of enumerations of algebraic data types! I may write a post about this in the future.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>There&rsquo;s not much use in keeping the non-lazy version of <code>interleave</code> around; I consider it broken. I only gave <code>lazy_interleave</code> a new name as a shortcut to appease the literate programming setup I&rsquo;m using.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>If you know of a way to detect the problem and provide a helpful error message, let me know!</p><p>Maybe stack overflow is a catchable exception, and could print an error message that suggests that the problem could be the order of the ADT cases. However, I say &ldquo;suggest&rdquo; because there could be other reasons for stack overflow; this merely detects a symptom rather than the problem.</p><p>I&rsquo;m thinking proper detection would require some sort of static analysis. Maybe it could be done with a <a href=https://ocaml.org/docs/metaprogramming>PPX</a>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>PearlCheck doesn&rsquo;t mention this problem, but if you copy the code up through &ldquo;Mark II: Algebraic Datatypes&rdquo; you can reproduce the problem on this example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>instance</span> <span style=color:#66d9ef>Listable</span> <span style=color:#66d9ef>Expr</span> <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Different from the one in the paper.</span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>-- Recursive case comes first / on the left.</span>
</span></span><span style=display:flex><span>  list <span style=color:#f92672>=</span> cons2 <span style=color:#66d9ef>Add</span> <span style=color:#f92672>\/</span> cons1 <span style=color:#66d9ef>Val</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>-- Gets stuck here on infinite recursion.</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>take</span> <span style=color:#ae81ff>5</span> (list <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Expr</span>])
</span></span></code></pre></div><p>The error goes away at &ldquo;Mark IV: Fair Enumeration&rdquo; because of the swap from <code>list</code> to <code>tiers</code>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://jeffreyfisher.net/tags/snailcheck/>snailcheck</a></li><li><a href=https://jeffreyfisher.net/tags/ocaml/>ocaml</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jeffreyfisher.net/>Jeffrey Fisher</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>