[{"content":" Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck\u0026rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.\nOur first stop will be laziness.\nProperty-based testing (PBT) Later posts will give a better idea of what property-based testing is, but for now I\u0026rsquo;ll give a quick definition.\nA property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.\nFor example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.\nlet prop xs = xs = reverse (reverse xs) The PBT library would apply this function to many different lists, making sure that it evaluates to true each time.\nMotivation for laziness Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.\nMany types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.\nAttempt #1 at the natural numbers The natural numbers are \\(\\{0, 1, 2, 3, \u0026hellip;\\}\\).\nThere is a pattern here: the \u0026ldquo;current\u0026rdquo; number is the previous number plus one.2 We repeatedly call the function fun n -\u0026gt; n + 1 on the \u0026ldquo;current\u0026rdquo; number, then consider the result the new \u0026ldquo;current\u0026rdquo; number.\nLet\u0026rsquo;s list them out.\nlet rec nats n = n :: nats (n + 1);; nats 0 Stack overflow during evaluation (looping recursion?). There\u0026rsquo;s a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn\u0026rsquo;t have enough memory to store them.\nWe need to be lazy, to delay computation until later.3\nLaziness How do we represent computation without immediately evaluating it?\nFunctions! If you define a function with an infinite loop, it won\u0026rsquo;t actually freeze your program unless you call the function.\nWe will represent lazy values with the type unit -\u0026gt; 'a, a function that takes one argument of type unit, and returns our value. unit is a special type that only has one value, which is also called \u0026ldquo;unit\u0026rdquo; and is written as empty paired parentheses, (). The argument to our lazy values carries no information, it\u0026rsquo;s more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.\ntype \u0026#39;t delayed = unit -\u0026gt; \u0026#39;t A more standard name for \u0026ldquo;delayed\u0026rdquo; would be thunk.\nHere are some sample lazy values:\nlet a : int delayed = fun () -\u0026gt; 42;; let b : int delayed = fun () -\u0026gt; List.fold_left (+) 0 [1;2;3];; For readability we will write a function for evaluating lazy values, force.\nlet force lazy_val = lazy_val () sprintf \u0026#34;%d\\n\u0026#34; (force a) ^ sprintf \u0026#34;%d\\n\u0026#34; (force b);; 42 6 Attempt #2 at natural numbers let rec up_from n = n :: up_from (n + 1) let nats : int list delayed = fun () -\u0026gt; up_from 0 We break out the implementation of nats into up_from.\nWe can now pass around the value nats without freezing, but if we try to unwrap the lazy value, we\u0026rsquo;ll still infinitely recurse. We\u0026rsquo;ve merely delayed a problematic expression, not fixed the problem.\nInstead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.\nWe want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.\nlet rec up_from n = n :: (fun () -\u0026gt; up_from (n + 1)) Line 1, characters 25-52: 1 | let rec up_from n = n :: (fun () -\u0026gt; up_from (n + 1));; ^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: This expression should not be a function, the expected type is \u0026#39;a list This code is basically what we want, but we\u0026rsquo;ll need to create our own type to represent it.\nLazy lists type \u0026#39;a lazylist = Nil | Cons of \u0026#39;a * \u0026#39;a lazylist delayed Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.\nSome example lazy lists:\nlet _ : \u0026#39;a lazylist = Nil;; let _ : int lazylist = Cons (1, fun () -\u0026gt; Nil);; let _ : string lazylist = Cons (\u0026#34;a\u0026#34;, fun () -\u0026gt; Cons (\u0026#34;b\u0026#34;, fun () -\u0026gt; Nil));; Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.\nInfinite: lazy lists Finite: lazy lists OR lists Lazy lists support both, so we always use them for the sake of uniformity.\nThe above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.\nlet rec int_range first last = if first \u0026gt; last then Nil else Cons (first, fun () -\u0026gt; int_range (first + 1) last) Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.\nlet one_to_twenty = int_range 1 20 To view lazy lists, we can grab the first few elements as a regular list.\n(* Returns a regular list of the first [n] elements of [ll]. If [n] greater than the length of [ll], returns [ll] as a regular list. *) let rec take n ll = if n = 0 then [] else ( match ll with | Nil -\u0026gt; [] | Cons (x, xs) -\u0026gt; x :: take (n - 1) (force xs) ) take 100 @@ int_range 1 20 Infinite lists The simplest infinite lists are just cycles.\nlet rec rocks name = Cons (name ^ \u0026#34; rocks!\u0026#34;, fun () -\u0026gt; rocks name) in take 3 @@ rocks \u0026#34;Property-based testing\u0026#34; It doesn\u0026rsquo;t have to be a function:\nlet rec xs = Cons (1, fun () -\u0026gt; Cons (2, fun () -\u0026gt; xs)) in take 5 xs Enumerating the natural numbers We\u0026rsquo;ve already seen the key idea, now we need to translate it to use lazylist.\nlet rec up_from n = Cons (n, fun () -\u0026gt; up_from (n + 1)) let nats : int lazylist = up_from 0 take 10 nats OCaml built-in Lazy OCaml has a built-in lazy library, which also does \u0026ldquo;memoization\u0026rdquo;. It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn\u0026rsquo;t have to, it also avoids redoing work it has already done.\nFor the rest of the series I will use the built-in Lazy.t.\nOCaml also has built-in library for delayed lists, Seq. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.\nSources I learned how lazy lists worked from the Cornell CS 3110 textbook, and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.\nhttp://jmct.cc/pearlcheck.pdf\nSnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.\nIf you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won\u0026rsquo;t be covered in this series.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn fact there is a representation of the natural numbers based on this fact, called the Peano numbers.\ntype peano = Z | S of peano Z = \u0026ldquo;zero\u0026rdquo;, S = \u0026ldquo;successor\u0026rdquo;.\nZero: Z One: S (Z) Two: S (S (Z)) \u0026#160;\u0026#x21a9;\u0026#xfe0e; Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.\nlet nats n = n : nats (n + 1) in let xs = nats 0 in take 10 xs [0,1,2,3,4,5,6,7,8,9] \u0026#160;\u0026#x21a9;\u0026#xfe0e; ","permalink":"https://jeffreyfisher.net/posts/snailcheck_laziness-from-scratch-in-ocaml/","summary":"Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck\u0026rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.","title":"SnailCheck: Laziness from scratch in OCaml"},{"content":"","permalink":"https://jeffreyfisher.net/about/","summary":"","title":"About"}]