[{"content":" Previous post in this series.\nIn the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.\nEnumerating booleans Enumerating booleans is simpler than the naturals, but it\u0026rsquo;s worth seeing. We\u0026rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.\nlet rec of_list xs = match xs with | [] -\u0026gt; Nil | x::xs -\u0026gt; Cons (x, fun () -\u0026gt; of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness. 1 When used in types \u0026ldquo;bool\u0026rdquo; will still refer to the the standard boolean type. But when used in expressions \u0026ldquo;bool\u0026rdquo; means this particular lazy list.\nEnumerating integers Problem Listing the integers is non-obvious because unlike the naturals there is no \u0026ldquo;starting point\u0026rdquo;. In math you can discuss the range \\((-\\infty, \\infty)\\), but in code we can\u0026rsquo;t start at negative infinity.\nOCaml\u0026rsquo;s int type does technically have a starting point, min_int, which seems to be \\(-2^{62}\\). Maybe we could do let int = up_from min_int? There are a few problems with this:\nFor a while all you\u0026rsquo;ll be seeing is negative numbers with a large magnitude. It\u0026rsquo;s easier to work with smaller numbers, and we also want to check zero and positive numbers. It\u0026rsquo;s also nice to try the simplest cases first, to hopefully report a failure that is easy to understand. \u0026ldquo;a while\u0026rdquo; is probably longer than a human lifespan. Rough calculations with a 5 millisecond time per check gave me an 11-digit number of years. 5 ms is perhaps a long time for executing a function, but even at the nanosecond scale you can\u0026rsquo;t exhaust the integers. A quick Internet search says even just incrementing a counter from 0 to 264 (not even checking properties) would take around 100 years. Sometimes we may want to use a special integer type that can represent arbitrarily-large integers. Then there will be no such thing as min_int. Solution There is a way to arrange the integers that gives them a starting point and gives the simplest cases first: \\(0, -1, 1, -2, 2, -3, 3, \\ldots\\) 2\nWe could express this as a single generator function like we did with the naturals:\nlet int : int lazylist = let rec ints\u0026#39; n = Cons (-n, fun () -\u0026gt; Cons (n, fun () -\u0026gt; ints\u0026#39; (n + 1))) in Cons (0, fun () -\u0026gt; ints\u0026#39; 1) ;; take 9 int - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4] However, we will express it in a way that I feel is more elegant. It will be useful to examine this technique with the integers first, because we will need it for more complex types later.\n\\[\\mathbb{Z} = \\mathbb{N} \\cup \\{-1, -2, -3, \\ldots\\}\\]\nWe can break the integers into pieces. If we combine the natural numbers and the negative integers, we get the set of all integers.\nThe common way to combine lists is appending.\nlet rec append xs ys = match xs, ys with | Nil, ys -\u0026gt; ys | Cons (x, xs), ys -\u0026gt; Cons (x, fun () -\u0026gt; append (force xs) ys) Let\u0026rsquo;s confirm that our lazy list append works:\ntake 6 @@ append (of_list [1;2;3]) (of_list [4;5;6]) - : int list = [1; 2; 3; 4; 5; 6] Now let\u0026rsquo;s try making the integers:\nlet rec down_from n = Cons (n, fun () -\u0026gt; down_from (n - 1)) let int = append nats (down_from (-1)) in take 9 int - : int list = [0; 1; 2; 3; 4; 5; 6; 7; 8] Oh no, we aren\u0026rsquo;t seeing any negatives! There are infinitely many naturals, so we\u0026rsquo;ll never get to the negatives.\nIf we make a slight change to our append function, we can get the behavior we want.\nlet rec interleave xs ys = match xs, ys with | Nil, ys -\u0026gt; ys | Cons (x, xs), ys -\u0026gt; Cons (x, fun () -\u0026gt; interleave ys (force xs)) (* Difference: append (force xs) ys *) (* Operator form. *) let ( @| ) = interleave let int : int lazylist = nats @| (down_from (-1)) In the recursive call we now swap the position of xs and ys, so we will get the behavior of alternating which list we grab from.\ntake 9 int - : int list = [0; -1; 1; -2; 2; -3; 3; -4; 4] Enumerating tuples Not all functions deal with simple scalar types. We also want to enumerate structured types, starting with tuples.\nFirst let\u0026rsquo;s add the ability to map over lazy lists.\nlet rec map f xs = match xs with | Nil -\u0026gt; Nil | Cons (x, xs) -\u0026gt; Cons (f x, fun () -\u0026gt; map f (force xs)) let square x = x * x in let perfect_squares = map square nats in take 10 perfect_squares - : int list = [0; 1; 4; 9; 16; 25; 36; 49; 64; 81] let rec pair_with x ll = map (fun y -\u0026gt; (x, y)) ll let rec pair xlist ylist = match xlist, ylist with | Cons (x, xrest), Cons (y, yrest) -\u0026gt; (* x paired with every y, interleaved with: pair xs ylist *) Cons ((x,y), fun () -\u0026gt; pair_with x (force yrest) @| pair (force xrest) ylist) | Nil, _ -\u0026gt; Nil | _, Nil -\u0026gt; Nil The key idea is to pair up the first x with every y in ylist, then combine that with the pairing of xrest with ylist.\nNote that pair_with x (force yrest) actually uses yrest, so it skips the first y. This is fine though because we have the pairing of x and the first y with Cons ((x,y), ...).\nThe Cons ((x,y), ...) piece is a bit inelegant, but necessary with the current implementation of interleave. Later we will solve this issue and clean up pair.\ntake 10 @@ pair_with 42 (of_list [1;2;3;4;5]) - : (int * int) list = [(42, 1); (42, 2); (42, 3); (42, 4); (42, 5)] take 10 @@ pair bool bool - : (bool * bool) list = [(true, true); (true, false); (false, true); (false, false)] take 10 @@ pair int int - : (int * int) list = [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2); (-1, 1); (0, -3)] We can of course mix different types.\ntake 10 @@ pair int bool - : (int * bool) list = [(0, true); (0, false); (-1, true); (-1, false); (1, true); (1, false); (-2, true); (-2, false); (2, true); (2, false)] Triples and n-tuples Two is a magic number. We can mimic n-tuples using nested pairs.\nFor example: (1, (2, 3)).\nlet triple xs ys zs = let triple_of_nest (a, (b, c)) = (a, b, c) in map triple_of_nest (pair xs (pair ys zs)) take 5 @@ triple int (pair bool int) int - : (int * (bool * int) * int) list = [(0, (true, 0), 0); (0, (true, 0), -1); (-1, (true, 0), 0); (0, (true, -1), 0); (-1, (true, 0), -1)] Enumerating algebraic data types (ADT) Here\u0026rsquo;s an interesting but still simple ADT: a binary tree.\ntype \u0026#39;a tree = Leaf | Branch of \u0026#39;a * \u0026#39;a tree * \u0026#39;a tree The enumeration of ADT constructors can be built directly off of tuple enumeration. We enumerate n-tuples, where n is the number of arguments to the constructor, then construct values.\nlet cons0 cons = of_list [cons] let cons1 cons a = map cons a let cons2 cons a b = map cons (pair a b) let cons3 cons a b c = map cons (triple a b c) In OCaml constructors cannot be passed around like functions, so we will define function wrappers to pass to consN.\nlet leaf = Leaf;; let branch (v, l, r) = Branch (v, l, r) The branch function converts an appropriate tuple into a tree branch.\nlet rec tree_a typ = cons0 leaf @| cons3 branch typ (tree_a typ) (tree_a typ) The type tree has two constructors. We start with the simple one, Leaf. It is a nullary constructor (no arguments), so we do cons0 leaf to enumerate it.\nThe other constructor is Branch, which has 3 parts, so we use cons3. The first part is of type 'a, the type the tree is parameterized by. We have the typ argument to take in the enumeration of 'a, so we do cons3 branch typ. The next two parts are both of type tree, so we have cons3 branch typ (tree_a typ) (tree_a typ).\nWriting enumerations of algebraic data types is a simple, mechanical process.3\nLet\u0026rsquo;s check out the result.\ntake 5 @@ (tree_a int) Stack overflow during evaluation (looping recursion?). Turns out I lied a bit. What went wrong?\nThe top level function in the body of tree_a is @| (a.k.a. interleave). OCaml uses strict evaluation, so we evaluate the arguments before evaluating the function. The left argument cons0 leaf is fine. The problem arises in the right argument, which has recursive calls to tree_a.\nWith recursion it is usually important to have:\nA base case. Recursive calls make the input \u0026ldquo;smaller\u0026rdquo;, approaching the base case. Conditional that checks whether to perform the base or recursive case. We have a base case of cons0 leaf, but we don\u0026rsquo;t have a conditional. Conditionals are special in that only some of their arguments/branches are evaluated each time, while functions have all of their arguments evaluated every time.\nThe problem is that we are always evaluating the recursive calls in cons3 branch typ (tree_a typ) (tree_a typ), so we recurse infinitely.\nSolution Imagine you are tree_a. This is roughly the behavior we want:\nFor the first tree, I\u0026rsquo;ll give you a Leaf. For the second tree, I\u0026rsquo;ll give you a Branch. To make a branch, I need to make a 'a. That\u0026rsquo;s easy, I use typ. I also need to make two of 'a tree. To do that, I make two nested calls of tree_a typ. I\u0026rsquo;m the first nested call. I\u0026rsquo;ll give you the first tree in the enumeration. That\u0026rsquo;s Leaf. I\u0026rsquo;m the second nested call. I\u0026rsquo;ll give you the first tree in the enumeration. That\u0026rsquo;s Leaf. I\u0026rsquo;ve completed giving Branch Leaf Leaf. For the third tree, \u0026hellip; If we grab the base case (Leaf) first, we can manage to build recursive cases (Branch).\nWe can\u0026rsquo;t do this with strict evaluation, so we need to add a bit of laziness. We will write lazy_interleave so that its arguments are both lazy (delayed), so we won\u0026rsquo;t get stuck on recursive calls encountered while evaluating the arguments to lazy_interleave.4\nlet rec lazy_interleave (xs : \u0026#39;a lazylist delayed) (ys: \u0026#39;a lazylist delayed) = let xs = force xs in match xs with | Nil -\u0026gt; force ys | Cons (x, xs) -\u0026gt; Cons (x, fun () -\u0026gt; lazy_interleave ys xs) let ( @|| ) = lazy_interleave Now we can enumerate trees.\nlet rec tree typ = let a = fun () -\u0026gt; cons0 leaf in let b = fun () -\u0026gt; cons3 branch typ (tree typ) (tree typ) in a @|| b in take 3 @@ tree int - : int tree list = [Leaf; Branch (0, Leaf, Leaf); Branch (0, Leaf, Branch (0, Leaf, Leaf))] Order matters Remember when I said we needed to grab the base case(s) before the recursive case(s)? With the current code, that\u0026rsquo;s true.\nlet rec tree_bad typ = let a = fun () -\u0026gt; cons3 branch typ (tree_bad typ) (tree_bad typ) in let b = fun () -\u0026gt; cons0 leaf in a @|| b in take 5 @@ tree_bad int Stack overflow during evaluation (looping recursion?). This is problematic. It\u0026rsquo;s annoying to remember and results in an unhelpful error message.5\nIt\u0026rsquo;s not simply a matter of laziness. PearlCheck, which is written in the lazy language Haskell, also faces this problem\u0026mdash;though it is solved later in the paper.6\nIt is possible to solve this problem in SnailCheck if we switch from simple enumerated lists to tiers, like PearlCheck uses. That may be covered in a later post, but for now you can check out the PearlCheck paper.\nEnumerating lists Lists in OCaml are essentially an algebraic data type, so we can enumerate them now.\nlet rec list typ = let cons (x, xs) = x :: xs in (fun () -\u0026gt; cons0 []) @|| (fun () -\u0026gt; cons2 cons typ (list typ)) take 5 @@ list bool - : bool list list = [[]; [true]; [true; true]; [false]; [true; true; true]] Elegant pair As promised, here is the elegant version of pair. This eliminates the Cons ((x,y), ...) and expresses it only with pair_with and a recursive call.\nlet rec elegant_pair xlist ylist = match xlist, ylist with | Cons (x, xrest), Cons (y, yrest) -\u0026gt; (* x paired with every y, then repeat with xrest. *) (fun () -\u0026gt; pair_with x ylist) @|| (fun () -\u0026gt; elegant_pair (force xrest) ylist) | Nil, _ -\u0026gt; Nil | _, Nil -\u0026gt; Nil take 10 @@ elegant_pair int int - : (int * int) list = [(0, 0); (-1, 0); (0, -1); (1, 0); (0, 1); (-1, -1); (0, -2); (-2, 0); (0, 2); (-1, 1)] take 10 @@ pair int int - : (int * int) list = [(0, 0); (0, -1); (-1, 0); (0, 1); (-1, -1); (0, -2); (1, 0); (0, 2); (-1, 1); (0, -3)] The order is a bit different, but it\u0026rsquo;s still correct.\nSee also This may be the last SnailCheck post, so I\u0026rsquo;ll leave you with some pointers if you\u0026rsquo;re interested in learning more.\nAs mentioned previously this series is essentially a port of the PearlCheck paper to OCaml.\nPearlCheck is a \u0026ldquo;tutorial reconstruction\u0026rdquo; of LeanCheck: https://hackage.haskell.org/package/leancheck So far the SnailCheck posts have covered the parts I struggled to translate to OCaml, but there is a lot more covered by PearlCheck that\u0026rsquo;s worth reading. According to PearlCheck, SmallCheck was the first enumerative PBT tool for Haskell.\nPaper: https://www.cs.york.ac.uk/fp/smallcheck/smallcheck.pdf An implementation: https://github.com/Bodigrim/smallcheck Feat: functional enumeration of algebraic types\nPaper: https://dl.acm.org/doi/abs/10.1145/2364506.2364515 \u0026ldquo;Feat provides efficient \u0026lsquo;random access\u0026rsquo; to enumerated values. The primary application is property-based testing, where it is used to define both random sampling (for example QuickCheck generators) and exhaustive enumeration (in the style of SmallCheck)\u0026rdquo; An OCaml library inspired by Feat: https://gitlab.inria.fr/fpottier/feat/ There are a variety of testing frameworks for OCaml. Several of them support some form of property-based testing.\nhttps://ocamlverse.net/content/testing.html We\u0026rsquo;re also doing punning because QCheck does it that way, and we want to be compatible with QCheck.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nApparently this is called the well-ordering of the integers. I\u0026rsquo;d seen this ordering before, and I recently learned the Well-Ordering Principle, but hadn\u0026rsquo;t made the connection until looking it up just now.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThat means we can automate the generation of enumerations of algebraic data types! I may write a post about this in the future.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nThere\u0026rsquo;s not much use in keeping the non-lazy version of interleave around; I consider it broken. I only gave lazy_interleave a new name as a shortcut to appease the literate programming setup I\u0026rsquo;m using.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIf you know of a way to detect the problem and provide a helpful error message, let me know!\nMaybe stack overflow is a catchable exception, and could print an error message that suggests that the problem could be the order of the ADT cases. However, I say \u0026ldquo;suggest\u0026rdquo; because there could be other reasons for stack overflow; this merely detects a symptom rather than the problem.\nI\u0026rsquo;m thinking proper detection would require some sort of static analysis. Maybe it could be done with a PPX.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nPearlCheck doesn\u0026rsquo;t mention this problem, but if you copy the code up through \u0026ldquo;Mark II: Algebraic Datatypes\u0026rdquo; you can reproduce the problem on this example:\ninstance Listable Expr where -- Different from the one in the paper. -- Recursive case comes first / on the left. list = cons2 Add \\/ cons1 Val -- Gets stuck here on infinite recursion. take 5 (list :: [Expr]) The error goes away at \u0026ldquo;Mark IV: Fair Enumeration\u0026rdquo; because of the swap from list to tiers.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://jeffreyfisher.net/posts/snailcheck-enum/","summary":"Previous post in this series.\nIn the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.\nEnumerating booleans Enumerating booleans is simpler than the naturals, but it\u0026rsquo;s worth seeing. We\u0026rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.\nlet rec of_list xs = match xs with | [] -\u0026gt; Nil | x::xs -\u0026gt; Cons (x, fun () -\u0026gt; of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness.","title":"SnailCheck: Enumerating types"},{"content":" Next post in this series.\nNote: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck\u0026rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.\nOur first stop will be laziness.\nProperty-based testing (PBT) Later posts will give a better idea of what property-based testing is, but for now I\u0026rsquo;ll give a quick definition.\nA property is a fact about our program, represented by a predicate (function that returns a boolean). A PBT library checks properties against many inputs.\nFor example, a function that reverses a list should always obey the property that if you apply it twice, you get back the original list.\nlet prop xs = xs = reverse (reverse xs) The PBT library would apply this function to many different lists, making sure that it evaluates to true each time.\nMotivation for laziness Because we are doing enumerative PBT, we want to list (enumerate) the values of a type, so we can plug them into our tests one after another.\nMany types have either too many values to reasonably store in memory at once, or infinitely many values. To handle this, we will be using lazy lists, which can be infinite in size.\nAttempt #1 at the natural numbers The natural numbers are \\(\\{0, 1, 2, 3, \u0026hellip;\\}\\).\nThere is a pattern here: the \u0026ldquo;current\u0026rdquo; number is the previous number plus one.2 We repeatedly call the function fun n -\u0026gt; n + 1 on the \u0026ldquo;current\u0026rdquo; number, then consider the result the new \u0026ldquo;current\u0026rdquo; number.\nLet\u0026rsquo;s list them out.\nlet rec nats n = n :: nats (n + 1);; nats 0 Stack overflow during evaluation (looping recursion?). There\u0026rsquo;s a small problem. There are infinitely many natural numbers. We will never reach the end of generating them, and even if we did we wouldn\u0026rsquo;t have enough memory to store them.\nWe need to be lazy, to delay computation until later.3\nLaziness How do we represent computation without immediately evaluating it?\nFunctions! If you define a function with an infinite loop, it won\u0026rsquo;t actually freeze your program unless you call the function.\nWe will represent lazy values with the type unit -\u0026gt; 'a, a function that takes one argument of type unit, and returns our value. unit is a special type that only has one value, which is also called \u0026ldquo;unit\u0026rdquo; and is written as empty paired parentheses, (). The argument to our lazy values carries no information, it\u0026rsquo;s more of an implementation detail. Really the intention is a function that takes no arguments, but this is not possible in OCaml.\ntype \u0026#39;t delayed = unit -\u0026gt; \u0026#39;t A more standard name for \u0026ldquo;delayed\u0026rdquo; would be thunk.\nHere are some sample lazy values:\nlet a : int delayed = fun () -\u0026gt; 42;; let b : int delayed = fun () -\u0026gt; List.fold_left (+) 0 [1;2;3];; For readability we will write a function for evaluating lazy values, force.\nlet force lazy_val = lazy_val () sprintf \u0026#34;%d\\n\u0026#34; (force a) ^ sprintf \u0026#34;%d\\n\u0026#34; (force b);; 42 6 Attempt #2 at natural numbers let rec up_from n = n :: up_from (n + 1) let nats : int list delayed = fun () -\u0026gt; up_from 0 We break out the implementation of nats into up_from.\nWe can now pass around the value nats without freezing, but if we try to unwrap the lazy value, we\u0026rsquo;ll still infinitely recurse. We\u0026rsquo;ve merely delayed a problematic expression, not fixed the problem.\nInstead of wrapping the whole problematic expression with laziness, we want to break the expression up so that it can be computed incrementally instead of all at once. This is how laziness benefits us when working with large or infinite lists.\nWe want to grab the first number and a lazy value representing the rest of the list. Then we can unwrap that lazy value to get the second number and a new lazy value.\nlet rec up_from n = n :: (fun () -\u0026gt; up_from (n + 1)) Line 1, characters 25-52: 1 | let rec up_from n = n :: (fun () -\u0026gt; up_from (n + 1));; ^^^^^^^^^^^^^^^^^^^^^^^^^^^ Error: This expression should not be a function, the expected type is \u0026#39;a list This code is basically what we want, but we\u0026rsquo;ll need to create our own type to represent it.\nLazy lists type \u0026#39;a lazylist = Nil | Cons of \u0026#39;a * \u0026#39;a lazylist delayed Each element of the list contains its own value, and a lazy value representing the next element in the list. This allows us to process one value at a time.\nSome example lazy lists:\nlet _ : \u0026#39;a lazylist = Nil;; let _ : int lazylist = Cons (1, fun () -\u0026gt; Nil);; let _ : string lazylist = Cons (\u0026#34;a\u0026#34;, fun () -\u0026gt; Cons (\u0026#34;b\u0026#34;, fun () -\u0026gt; Nil));; Though we created lazy lists to have infinite lists, we can have finite lazy lists as well. We want to enumerate both finite and infinite types.\nInfinite: lazy lists Finite: lazy lists OR lists Lazy lists support both, so we always use them for the sake of uniformity.\nThe above examples explicitly specify finite lists. If we have a large (but still finite) list, we may want to avoid computing the whole thing up front, to make use of the benefits of laziness.\nlet rec int_range first last = if first \u0026gt; last then Nil else Cons (first, fun () -\u0026gt; int_range (first + 1) last) Now we can dynamically represent an arbitrary range of numbers. We could write it out explicitly, but it would take up more memory because the whole thing is evaluated at once; and of course this way has a lot less typing.\nlet one_to_twenty = int_range 1 20 To view lazy lists, we can grab the first few elements as a regular list.\n(* Returns a regular list of the first [n] elements of [ll]. If [n] greater than the length of [ll], returns [ll] as a regular list. *) let rec take n ll = if n = 0 then [] else ( match ll with | Nil -\u0026gt; [] | Cons (x, xs) -\u0026gt; x :: take (n - 1) (force xs) ) take 100 @@ int_range 1 20 Infinite lists The simplest infinite lists are just cycles.\nlet rec rocks name = Cons (name ^ \u0026#34; rocks!\u0026#34;, fun () -\u0026gt; rocks name) in take 3 @@ rocks \u0026#34;Property-based testing\u0026#34; It doesn\u0026rsquo;t have to be a function:\nlet rec xs = Cons (1, fun () -\u0026gt; Cons (2, fun () -\u0026gt; xs)) in take 5 xs Enumerating the natural numbers We\u0026rsquo;ve already seen the key idea, now we need to translate it to use lazylist.\nlet rec up_from n = Cons (n, fun () -\u0026gt; up_from (n + 1)) let nats : int lazylist = up_from 0 take 10 nats OCaml built-in Lazy OCaml has a built-in lazy library, which also does \u0026ldquo;memoization\u0026rdquo;. It remembers the result, so the next time you force the lazy value it quickly returns the stored result. It not only avoids doing work it doesn\u0026rsquo;t have to, it also avoids redoing work it has already done.\nOCaml also has built-in library for delayed lists, Seq. I will not use it in this article series because we will encounter an interesting problem from using our own lazy lists.\nSources I learned how lazy lists worked from the Cornell CS 3110 textbook, and my explanation of enumerating naturals ended up being essentially the same as the CS 3110 one.\nhttp://jmct.cc/pearlcheck.pdf\nSnailCheck would not be possible without PearlCheck. You can think of SnailCheck as a port of PearlCheck to OCaml.\nIf you are more interested in Haskell than OCaml, you may want to read the PearlCheck paper instead of this series. You should also check out PearlCheck anyways, as it is a great paper and much of its material probably won\u0026rsquo;t be covered in this series.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nIn fact there is a representation of the natural numbers based on this fact, called the Peano numbers.\ntype peano = Z | S of peano Z = \u0026ldquo;zero\u0026rdquo;, S = \u0026ldquo;successor\u0026rdquo;.\nZero: Z One: S (Z) Two: S (S (Z)) \u0026#160;\u0026#x21a9;\u0026#xfe0e; Ignoring slight syntactic differences, this definition for a list of the natural numbers would do exactly what we want in Haskell, which is lazy by default.\nlet nats n = n : nats (n + 1) in let xs = nats 0 in take 10 xs [0,1,2,3,4,5,6,7,8,9] \u0026#160;\u0026#x21a9;\u0026#xfe0e; ","permalink":"https://jeffreyfisher.net/posts/snailcheck-lazy/","summary":"Next post in this series.\nNote: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.\nI will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheck 1 and LeanCheck. Like them, SnailCheck\u0026rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.","title":"SnailCheck: Laziness from scratch in OCaml"},{"content":"Contact Email jeffrey@jeffreyfisher.net (mailto link)\n","permalink":"https://jeffreyfisher.net/about/","summary":"Contact Email jeffrey@jeffreyfisher.net (mailto link)","title":"About"},{"content":"Small Conway\u0026rsquo;s Game of Life URL: https://jeffreyfisher.net/life/\nSmall and limited JavaScript implementation of Conway\u0026rsquo;s Game of Life using p5.js.\nCollaborative projects Google CSSI: Keyano, a web-based digital instrument Demo: https://jeffreyfisher.net/keyano/ Repository: https://github.com/jegfish/keyano Authors: Antonio, Tiana, Jeffrey Created for our final project for Google Computer Science Summer Institute (CSSI).\n","permalink":"https://jeffreyfisher.net/projects/","summary":"Small Conway\u0026rsquo;s Game of Life URL: https://jeffreyfisher.net/life/\nSmall and limited JavaScript implementation of Conway\u0026rsquo;s Game of Life using p5.js.\nCollaborative projects Google CSSI: Keyano, a web-based digital instrument Demo: https://jeffreyfisher.net/keyano/ Repository: https://github.com/jegfish/keyano Authors: Antonio, Tiana, Jeffrey Created for our final project for Google Computer Science Summer Institute (CSSI).","title":"Projects"},{"content":"","permalink":"https://jeffreyfisher.net/tags/","summary":"tags","title":"Tags"}]