<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Jeffrey Fisher</title><link>https://jeffreyfisher.net/</link><description>Recent content on Jeffrey Fisher</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Jun 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://jeffreyfisher.net/index.xml" rel="self" type="application/rss+xml"/><item><title>SnailCheck: Enumerating types</title><link>https://jeffreyfisher.net/posts/snailcheck-enum/</link><pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate><guid>https://jeffreyfisher.net/posts/snailcheck-enum/</guid><description>Previous post in this series.
In the previous post we saw the enumeration of the natural numbers. Now we will learn to enumerate more complex types.
Enumerating booleans Enumerating booleans is simpler than the naturals, but it&amp;rsquo;s worth seeing. We&amp;rsquo;ll make a convenience function for converting a regular list to a lazy list; it will also be useful for testing and for enumerating other types with few values.
let rec of_list xs = match xs with | [] -&amp;gt; Nil | x::xs -&amp;gt; Cons (x, fun () -&amp;gt; of_list xs) let bool : bool lazylist = of_list [true; false] take 2 bool - : bool list = [true; false] Note: We are doing some punning here to allow conciseness.</description></item><item><title>SnailCheck: Laziness from scratch in OCaml</title><link>https://jeffreyfisher.net/posts/snailcheck-lazy/</link><pubDate>Sun, 04 Jun 2023 00:00:00 +0000</pubDate><guid>https://jeffreyfisher.net/posts/snailcheck-lazy/</guid><description>Next post in this series.
Note: You do not need to be well versed in OCaml or property-based testing to understand this article. I believe the core idea should apply to any language with closures.
I will be taking you through the design of an enumerative property-based testing (PBT) library, inspired by PearlCheckÂ 1 and LeanCheck. Like them, SnailCheck&amp;rsquo;s main focus is on being easy to understand. One reason I am doing this is to develop a deeper understanding of the details that PearlCheck (rightfully) skips.</description></item><item><title>About</title><link>https://jeffreyfisher.net/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jeffreyfisher.net/about/</guid><description>Contact Email jeffrey@jeffreyfisher.net (mailto link)</description></item><item><title>Tags</title><link>https://jeffreyfisher.net/tags/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jeffreyfisher.net/tags/</guid><description>tags</description></item></channel></rss>